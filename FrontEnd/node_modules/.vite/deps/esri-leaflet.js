import {
  require_leaflet_src
} from "./chunk-K3KMILHC.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/esri-leaflet/package.json
var package_default = {
  name: "esri-leaflet",
  description: "Leaflet plugins for consuming ArcGIS Online and ArcGIS Server services.",
  version: "3.0.19",
  author: "Patrick Arlt <parlt@esri.com> (http://patrickarlt.com)",
  bugs: {
    url: "https://github.com/esri/esri-leaflet/issues"
  },
  contributors: [
    "Patrick Arlt <parlt@esri.com> (http://patrickarlt.com)",
    "John Gravois (https://johngravois.com)",
    "Gavin Rehkemper <grehkemper@esri.com> (https://gavinr.com)",
    "Jacob Wasilkowski (https://jwasilgeo.github.io)"
  ],
  dependencies: {
    "@terraformer/arcgis": "^2.1.0",
    "tiny-binary-search": "^1.0.3"
  },
  devDependencies: {
    "@rollup/plugin-json": "^6.0.0",
    "@rollup/plugin-node-resolve": "^15.0.1",
    "@rollup/plugin-terser": "^0.3.0",
    chai: "4.3.7",
    "chokidar-cli": "^3.0.0",
    eslint: "^9.24.0",
    "eslint-config-mourner": "^4.0.2",
    "eslint-config-prettier": "^10.1.2",
    "eslint-plugin-import-x": "^4.10.2",
    "gh-release": "^7.0.1",
    "highlight.js": "^11.7.0",
    "http-server": "^14.1.1",
    husky: "^1.1.1",
    karma: "^6.4.1",
    "karma-chrome-launcher": "^3.1.1",
    "karma-coverage": "^2.2.0",
    "karma-edgium-launcher": "github:matracey/karma-edgium-launcher",
    "karma-firefox-launcher": "^2.1.2",
    "karma-mocha": "^2.0.1",
    "karma-mocha-reporter": "^2.2.5",
    "karma-safari-launcher": "~1.0.0",
    "karma-sinon-chai": "^2.0.2",
    "karma-sourcemap-loader": "^0.3.8",
    leaflet: "^1.6.0",
    mkdirp: "^1.0.4",
    mocha: "^10.2.0",
    "npm-run-all": "^4.1.5",
    prettier: "3.5.3",
    rollup: "^2.79.1",
    sinon: "^15.0.1",
    "sinon-chai": "3.7.0"
  },
  files: [
    "src/**/*.js",
    "dist/esri-leaflet.js",
    "dist/esri-leaflet.js.map",
    "dist/esri-leaflet-debug.js.map",
    "dist/siteData.json",
    "profiles/*.js"
  ],
  homepage: "https://developers.arcgis.com/esri-leaflet/",
  module: "src/EsriLeaflet.js",
  "jsnext:main": "src/EsriLeaflet.js",
  jspm: {
    registry: "npm",
    format: "es6",
    main: "src/EsriLeaflet.js"
  },
  keywords: [
    "arcgis",
    "esri",
    "esri leaflet",
    "gis",
    "leaflet plugin",
    "mapping"
  ],
  license: "Apache-2.0",
  main: "dist/esri-leaflet-debug.js",
  peerDependencies: {
    leaflet: "^1.0.0"
  },
  readmeFilename: "README.md",
  repository: {
    type: "git",
    url: "git@github.com:Esri/esri-leaflet.git"
  },
  scripts: {
    build: "rollup -c profiles/debug.js & rollup -c profiles/production.js",
    lint: "npm run eslint && npm run prettier",
    eslint: "eslint .",
    eslintfix: "npm run eslint -- --fix",
    prettier: "npx prettier . --check",
    prettierfix: "npx prettier . --write",
    prebuild: "mkdirp dist",
    pretest: "npm run build",
    release: "./scripts/release.sh",
    "start-watch": 'chokidar src -c "npm run build"',
    start: "run-p start-watch serve",
    serve: "http-server -p 5000 -c-1 -o",
    test: "npm run lint && karma start"
  },
  unpkg: "dist/esri-leaflet-debug.js",
  husky: {
    hooks: {
      "pre-commit": "npm run lint"
    }
  }
};

// node_modules/esri-leaflet/src/Support.js
var cors = window.XMLHttpRequest && "withCredentials" in new window.XMLHttpRequest();
var pointerEvents = document.documentElement.style.pointerEvents === "";
var Support = {
  cors,
  pointerEvents
};

// node_modules/esri-leaflet/src/Options.js
var options = {
  attributionWidthOffset: 55
};

// node_modules/esri-leaflet/src/Util.js
var import_leaflet2 = __toESM(require_leaflet_src());

// node_modules/esri-leaflet/src/Request.js
var import_leaflet = __toESM(require_leaflet_src());
var callbacks = 0;
function serialize(params) {
  let data = "";
  params.f = params.f || "json";
  for (const key in params) {
    if (Object.hasOwn(params, key)) {
      const param = params[key];
      const type = Object.prototype.toString.call(param);
      let value;
      if (data.length) {
        data += "&";
      }
      if (type === "[object Array]") {
        value = Object.prototype.toString.call(param[0]) === "[object Object]" ? JSON.stringify(param) : param.join(",");
      } else if (type === "[object Object]") {
        value = JSON.stringify(param);
      } else if (type === "[object Date]") {
        value = param.valueOf();
      } else {
        value = param;
      }
      data += `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
    }
  }
  const APOSTROPHE_URL_ENCODE = "%27";
  return data.replaceAll("'", APOSTROPHE_URL_ENCODE);
}
function createRequest(callback, context) {
  const httpRequest = new window.XMLHttpRequest();
  httpRequest.onerror = function() {
    httpRequest.onreadystatechange = import_leaflet.Util.falseFn;
    callback.call(
      context,
      {
        error: {
          code: 500,
          message: "XMLHttpRequest error"
        }
      },
      null
    );
  };
  httpRequest.onreadystatechange = function() {
    let response;
    let error;
    if (httpRequest.readyState === 4) {
      try {
        response = JSON.parse(httpRequest.responseText);
      } catch (e) {
        response = null;
        error = {
          code: 500,
          message: "Could not parse response as JSON. This could also be caused by a CORS or XMLHttpRequest error."
        };
      }
      if (!error && response.error) {
        error = response.error;
        response = null;
      }
      httpRequest.onerror = import_leaflet.Util.falseFn;
      callback.call(context, error, response);
    }
  };
  httpRequest.ontimeout = function() {
    this.onerror();
  };
  return httpRequest;
}
function xmlHttpPost(url, params, callback, context) {
  const httpRequest = createRequest(callback, context);
  httpRequest.open("POST", url);
  if (typeof context !== "undefined" && context !== null) {
    if (typeof context.options !== "undefined") {
      httpRequest.timeout = context.options.timeout;
    }
  }
  httpRequest.setRequestHeader(
    "Content-Type",
    "application/x-www-form-urlencoded; charset=UTF-8"
  );
  httpRequest.send(serialize(params));
  return httpRequest;
}
function xmlHttpGet(url, params, callback, context) {
  const httpRequest = createRequest(callback, context);
  httpRequest.open("GET", `${url}?${serialize(params)}`, true);
  if (typeof context !== "undefined" && context !== null) {
    if (typeof context.options !== "undefined") {
      httpRequest.timeout = context.options.timeout;
      if (context.options.withCredentials) {
        httpRequest.withCredentials = true;
      }
    }
  }
  httpRequest.send(null);
  return httpRequest;
}
function request(url, params, callback, context) {
  const paramString = serialize(params);
  const httpRequest = createRequest(callback, context);
  const requestLength = `${url}?${paramString}`.length;
  if (requestLength <= 2e3 && Support.cors) {
    httpRequest.open("GET", `${url}?${paramString}`);
  } else if (requestLength > 2e3 && Support.cors) {
    httpRequest.open("POST", url);
    httpRequest.setRequestHeader(
      "Content-Type",
      "application/x-www-form-urlencoded; charset=UTF-8"
    );
  }
  if (typeof context !== "undefined" && context !== null) {
    if (typeof context.options !== "undefined") {
      httpRequest.timeout = context.options.timeout;
      if (context.options.withCredentials) {
        httpRequest.withCredentials = true;
      }
    }
  }
  if (requestLength <= 2e3 && Support.cors) {
    httpRequest.send(null);
  } else if (requestLength > 2e3 && Support.cors) {
    httpRequest.send(paramString);
  } else if (requestLength <= 2e3 && !Support.cors) {
    return jsonp(url, params, callback, context);
  } else {
    warn(
      `a request to ${url} was longer then 2000 characters and this browser cannot make a cross-domain post request. Please use a proxy https://developers.arcgis.com/esri-leaflet/api-reference/request/`
    );
    return;
  }
  return httpRequest;
}
function jsonp(url, params, callback, context) {
  window._EsriLeafletCallbacks = window._EsriLeafletCallbacks || {};
  const callbackId = `c${callbacks}`;
  params.callback = `window._EsriLeafletCallbacks.${callbackId}`;
  window._EsriLeafletCallbacks[callbackId] = function(response) {
    if (window._EsriLeafletCallbacks[callbackId] !== true) {
      let error;
      const responseType = Object.prototype.toString.call(response);
      if (!(responseType === "[object Object]" || responseType === "[object Array]")) {
        error = {
          error: {
            code: 500,
            message: "Expected array or object as JSONP response"
          }
        };
        response = null;
      }
      if (!error && response.error) {
        error = response;
        response = null;
      }
      callback.call(context, error, response);
      window._EsriLeafletCallbacks[callbackId] = true;
    }
  };
  const script = import_leaflet.DomUtil.create("script", null, document.body);
  script.type = "text/javascript";
  script.src = `${url}?${serialize(params)}`;
  script.id = callbackId;
  script.onerror = function(error) {
    if (error && window._EsriLeafletCallbacks[callbackId] !== true) {
      const err = {
        error: {
          code: 500,
          message: "An unknown error occurred"
        }
      };
      callback.call(context, err);
      window._EsriLeafletCallbacks[callbackId] = true;
    }
  };
  import_leaflet.DomUtil.addClass(script, "esri-leaflet-jsonp");
  callbacks++;
  return {
    id: callbackId,
    url: script.src,
    abort() {
      window._EsriLeafletCallbacks._callback[callbackId]({
        code: 0,
        message: "Request aborted."
      });
    }
  };
}
var get = Support.cors ? xmlHttpGet : jsonp;
get.CORS = xmlHttpGet;
get.JSONP = jsonp;
function warn(...args) {
  if (console && console.warn) {
    console.warn.apply(console, args);
  }
}
var Request = {
  request,
  get,
  post: xmlHttpPost
};
var Request_default = Request;

// node_modules/@terraformer/arcgis/dist/t-arcgis.esm.js
var edgeIntersectsEdge = function edgeIntersectsEdge2(a1, a2, b1, b2) {
  var uaT = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);
  var ubT = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);
  var uB = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);
  if (uB !== 0) {
    var ua = uaT / uB;
    var ub = ubT / uB;
    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
      return true;
    }
  }
  return false;
};
var coordinatesContainPoint = function coordinatesContainPoint2(coordinates, point2) {
  var contains = false;
  for (var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {
    if ((coordinates[i][1] <= point2[1] && point2[1] < coordinates[j][1] || coordinates[j][1] <= point2[1] && point2[1] < coordinates[i][1]) && point2[0] < (coordinates[j][0] - coordinates[i][0]) * (point2[1] - coordinates[i][1]) / (coordinates[j][1] - coordinates[i][1]) + coordinates[i][0]) {
      contains = !contains;
    }
  }
  return contains;
};
var pointsEqual = function pointsEqual2(a, b) {
  for (var i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
};
var arrayIntersectsArray = function arrayIntersectsArray2(a, b) {
  for (var i = 0; i < a.length - 1; i++) {
    for (var j = 0; j < b.length - 1; j++) {
      if (edgeIntersectsEdge(a[i], a[i + 1], b[j], b[j + 1])) {
        return true;
      }
    }
  }
  return false;
};
var closeRing = function closeRing2(coordinates) {
  if (!pointsEqual(coordinates[0], coordinates[coordinates.length - 1])) {
    coordinates.push(coordinates[0]);
  }
  return coordinates;
};
var ringIsClockwise = function ringIsClockwise2(ringToTest) {
  var total = 0;
  var i = 0;
  var rLength = ringToTest.length;
  var pt1 = ringToTest[i];
  var pt2;
  for (i; i < rLength - 1; i++) {
    pt2 = ringToTest[i + 1];
    total += (pt2[0] - pt1[0]) * (pt2[1] + pt1[1]);
    pt1 = pt2;
  }
  return total >= 0;
};
var shallowClone = function shallowClone2(obj) {
  var target = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      target[i] = obj[i];
    }
  }
  return target;
};
var coordinatesContainCoordinates = function coordinatesContainCoordinates2(outer, inner) {
  var intersects = arrayIntersectsArray(outer, inner);
  var contains = coordinatesContainPoint(outer, inner[0]);
  if (!intersects && contains) {
    return true;
  }
  return false;
};
var convertRingsToGeoJSON = function convertRingsToGeoJSON2(rings) {
  var outerRings = [];
  var holes = [];
  var x;
  var outerRing;
  var hole;
  for (var r = 0; r < rings.length; r++) {
    var ring = closeRing(rings[r].slice(0));
    if (ring.length < 4) {
      continue;
    }
    if (ringIsClockwise(ring)) {
      var polygon = [ring.slice().reverse()];
      outerRings.push(polygon);
    } else {
      holes.push(ring.slice().reverse());
    }
  }
  var uncontainedHoles = [];
  while (holes.length) {
    hole = holes.pop();
    var contained = false;
    for (x = outerRings.length - 1; x >= 0; x--) {
      outerRing = outerRings[x][0];
      if (coordinatesContainCoordinates(outerRing, hole)) {
        outerRings[x].push(hole);
        contained = true;
        break;
      }
    }
    if (!contained) {
      uncontainedHoles.push(hole);
    }
  }
  while (uncontainedHoles.length) {
    hole = uncontainedHoles.pop();
    var intersects = false;
    for (x = outerRings.length - 1; x >= 0; x--) {
      outerRing = outerRings[x][0];
      if (arrayIntersectsArray(outerRing, hole)) {
        outerRings[x].push(hole);
        intersects = true;
        break;
      }
    }
    if (!intersects) {
      outerRings.push([hole.reverse()]);
    }
  }
  if (outerRings.length === 1) {
    return {
      type: "Polygon",
      coordinates: outerRings[0]
    };
  } else {
    return {
      type: "MultiPolygon",
      coordinates: outerRings
    };
  }
};
var getId = function getId2(attributes, idAttribute) {
  var keys = idAttribute ? [idAttribute, "OBJECTID", "FID"] : ["OBJECTID", "FID"];
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (key in attributes && (typeof attributes[key] === "string" || typeof attributes[key] === "number")) {
      return attributes[key];
    }
  }
  throw Error("No valid id attribute found");
};
var arcgisToGeoJSON = function arcgisToGeoJSON2(arcgis, idAttribute) {
  var geojson = {};
  if (arcgis.features) {
    geojson.type = "FeatureCollection";
    geojson.features = [];
    for (var i = 0; i < arcgis.features.length; i++) {
      geojson.features.push(arcgisToGeoJSON2(arcgis.features[i], idAttribute));
    }
  }
  if (typeof arcgis.x === "number" && typeof arcgis.y === "number") {
    geojson.type = "Point";
    geojson.coordinates = [arcgis.x, arcgis.y];
    if (typeof arcgis.z === "number") {
      geojson.coordinates.push(arcgis.z);
    }
  }
  if (arcgis.points) {
    geojson.type = "MultiPoint";
    geojson.coordinates = arcgis.points.slice(0);
  }
  if (arcgis.paths) {
    if (arcgis.paths.length === 1) {
      geojson.type = "LineString";
      geojson.coordinates = arcgis.paths[0].slice(0);
    } else {
      geojson.type = "MultiLineString";
      geojson.coordinates = arcgis.paths.slice(0);
    }
  }
  if (arcgis.rings) {
    geojson = convertRingsToGeoJSON(arcgis.rings.slice(0));
  }
  if (typeof arcgis.xmin === "number" && typeof arcgis.ymin === "number" && typeof arcgis.xmax === "number" && typeof arcgis.ymax === "number") {
    geojson.type = "Polygon";
    geojson.coordinates = [[[arcgis.xmax, arcgis.ymax], [arcgis.xmin, arcgis.ymax], [arcgis.xmin, arcgis.ymin], [arcgis.xmax, arcgis.ymin], [arcgis.xmax, arcgis.ymax]]];
  }
  if (arcgis.geometry || arcgis.attributes) {
    geojson.type = "Feature";
    geojson.geometry = arcgis.geometry ? arcgisToGeoJSON2(arcgis.geometry) : null;
    geojson.properties = arcgis.attributes ? shallowClone(arcgis.attributes) : null;
    if (arcgis.attributes) {
      try {
        geojson.id = getId(arcgis.attributes, idAttribute);
      } catch (err) {
      }
    }
  }
  if (JSON.stringify(geojson.geometry) === JSON.stringify({})) {
    geojson.geometry = null;
  }
  if (arcgis.spatialReference && arcgis.spatialReference.wkid && arcgis.spatialReference.wkid !== 4326) {
    console.warn("Object converted in non-standard crs - " + JSON.stringify(arcgis.spatialReference));
  }
  return geojson;
};
var orientRings = function orientRings2(poly) {
  var output = [];
  var polygon = poly.slice(0);
  var outerRing = closeRing(polygon.shift().slice(0));
  if (outerRing.length >= 4) {
    if (!ringIsClockwise(outerRing)) {
      outerRing.reverse();
    }
    output.push(outerRing);
    for (var i = 0; i < polygon.length; i++) {
      var hole = closeRing(polygon[i].slice(0));
      if (hole.length >= 4) {
        if (ringIsClockwise(hole)) {
          hole.reverse();
        }
        output.push(hole);
      }
    }
  }
  return output;
};
var flattenMultiPolygonRings = function flattenMultiPolygonRings2(rings) {
  var output = [];
  for (var i = 0; i < rings.length; i++) {
    var polygon = orientRings(rings[i]);
    for (var x = polygon.length - 1; x >= 0; x--) {
      var ring = polygon[x].slice(0);
      output.push(ring);
    }
  }
  return output;
};
var geojsonToArcGIS = function geojsonToArcGIS2(geojson, idAttribute) {
  idAttribute = idAttribute || "OBJECTID";
  var spatialReference = {
    wkid: 4326
  };
  var result = {};
  var i;
  switch (geojson.type) {
    case "Point":
      result.x = geojson.coordinates[0];
      result.y = geojson.coordinates[1];
      if (geojson.coordinates[2] != null) {
        result.z = geojson.coordinates[2];
      }
      result.spatialReference = spatialReference;
      break;
    case "MultiPoint":
      result.points = geojson.coordinates.slice(0);
      if (geojson.coordinates[0][2] != null) {
        result.hasZ = true;
      }
      result.spatialReference = spatialReference;
      break;
    case "LineString":
      result.paths = [geojson.coordinates.slice(0)];
      if (geojson.coordinates[0][2] != null) {
        result.hasZ = true;
      }
      result.spatialReference = spatialReference;
      break;
    case "MultiLineString":
      result.paths = geojson.coordinates.slice(0);
      if (geojson.coordinates[0][0][2] != null) {
        result.hasZ = true;
      }
      result.spatialReference = spatialReference;
      break;
    case "Polygon":
      result.rings = orientRings(geojson.coordinates.slice(0));
      if (geojson.coordinates[0][0][2] != null) {
        result.hasZ = true;
      }
      result.spatialReference = spatialReference;
      break;
    case "MultiPolygon":
      result.rings = flattenMultiPolygonRings(geojson.coordinates.slice(0));
      if (geojson.coordinates[0][0][0][2] != null) {
        result.hasZ = true;
      }
      result.spatialReference = spatialReference;
      break;
    case "Feature":
      if (geojson.geometry) {
        result.geometry = geojsonToArcGIS2(geojson.geometry, idAttribute);
      }
      result.attributes = geojson.properties ? shallowClone(geojson.properties) : {};
      if (geojson.id) {
        result.attributes[idAttribute] = geojson.id;
      }
      break;
    case "FeatureCollection":
      result = [];
      for (i = 0; i < geojson.features.length; i++) {
        result.push(geojsonToArcGIS2(geojson.features[i], idAttribute));
      }
      break;
    case "GeometryCollection":
      result = [];
      for (i = 0; i < geojson.geometries.length; i++) {
        result.push(geojsonToArcGIS2(geojson.geometries[i], idAttribute));
      }
      break;
  }
  return result;
};

// node_modules/esri-leaflet/src/Util.js
var POWERED_BY_ESRI_ATTRIBUTION_STRING = 'Powered by <a href="https://www.esri.com">Esri</a>';
function geojsonToArcGIS3(geojson, idAttr) {
  return geojsonToArcGIS(geojson, idAttr);
}
function arcgisToGeoJSON3(arcgis, idAttr) {
  return arcgisToGeoJSON(arcgis, idAttr);
}
function extentToBounds(extent) {
  if (extent.xmin !== "NaN" && extent.ymin !== "NaN" && extent.xmax !== "NaN" && extent.ymax !== "NaN") {
    const sw = (0, import_leaflet2.latLng)(extent.ymin, extent.xmin);
    const ne = (0, import_leaflet2.latLng)(extent.ymax, extent.xmax);
    return (0, import_leaflet2.latLngBounds)(sw, ne);
  }
  return null;
}
function boundsToExtent(bounds2) {
  bounds2 = (0, import_leaflet2.latLngBounds)(bounds2);
  return {
    xmin: bounds2.getSouthWest().lng,
    ymin: bounds2.getSouthWest().lat,
    xmax: bounds2.getNorthEast().lng,
    ymax: bounds2.getNorthEast().lat,
    spatialReference: {
      wkid: 4326
    }
  };
}
var knownFieldNames = /^(OBJECTID|FID|OID|ID)$/i;
function _findIdAttributeFromResponse(response) {
  let result;
  if (response.objectIdFieldName) {
    result = response.objectIdFieldName;
  } else if (response.fields) {
    for (let j = 0; j <= response.fields.length - 1; j++) {
      if (response.fields[j].type === "esriFieldTypeOID") {
        result = response.fields[j].name;
        break;
      }
    }
    if (!result) {
      for (let j = 0; j <= response.fields.length - 1; j++) {
        if (response.fields[j].name.match(knownFieldNames)) {
          result = response.fields[j].name;
          break;
        }
      }
    }
  }
  return result;
}
function _findIdAttributeFromFeature(feature) {
  for (const key in feature.attributes) {
    if (key.match(knownFieldNames)) {
      return key;
    }
  }
}
function responseToFeatureCollection(response, idAttribute) {
  let objectIdField;
  const features = response.features || response.results;
  const count = features && features.length;
  if (idAttribute) {
    objectIdField = idAttribute;
  } else {
    objectIdField = _findIdAttributeFromResponse(response);
  }
  const featureCollection = {
    type: "FeatureCollection",
    features: []
  };
  if (count) {
    for (let i = features.length - 1; i >= 0; i--) {
      const feature = arcgisToGeoJSON3(
        features[i],
        objectIdField || _findIdAttributeFromFeature(features[i])
      );
      featureCollection.features.push(feature);
    }
  }
  return featureCollection;
}
function cleanUrl(url) {
  url = import_leaflet2.Util.trim(url);
  if (url[url.length - 1] !== "/") {
    url += "/";
  }
  return url;
}
function getUrlParams(options2) {
  if (options2.url.indexOf("?") !== -1) {
    options2.requestParams = options2.requestParams || {};
    const queryString = options2.url.substring(options2.url.indexOf("?") + 1);
    options2.url = options2.url.split("?")[0];
    options2.requestParams = JSON.parse(
      `{"${decodeURI(queryString).replace(/"/g, '\\"').replace(/&/g, '","').replace(/=/g, '":"')}"}`
    );
  }
  options2.url = cleanUrl(options2.url.split("?")[0]);
  return options2;
}
function isArcgisOnline(url) {
  return /^(?!.*utility\.arcgis\.com).*\.arcgis\.com.*FeatureServer/i.test(url);
}
function geojsonTypeToArcGIS(geoJsonType) {
  let arcgisGeometryType;
  switch (geoJsonType) {
    case "Point":
      arcgisGeometryType = "esriGeometryPoint";
      break;
    case "MultiPoint":
      arcgisGeometryType = "esriGeometryMultipoint";
      break;
    case "LineString":
      arcgisGeometryType = "esriGeometryPolyline";
      break;
    case "MultiLineString":
      arcgisGeometryType = "esriGeometryPolyline";
      break;
    case "Polygon":
      arcgisGeometryType = "esriGeometryPolygon";
      break;
    case "MultiPolygon":
      arcgisGeometryType = "esriGeometryPolygon";
      break;
  }
  return arcgisGeometryType;
}
function calcAttributionWidth(map) {
  return `${map.getSize().x - options.attributionWidthOffset}px`;
}
function setEsriAttribution(map) {
  if (!map.attributionControl) {
    return;
  }
  if (!map.attributionControl._esriAttributionLayerCount) {
    map.attributionControl._esriAttributionLayerCount = 0;
  }
  if (map.attributionControl._esriAttributionLayerCount === 0) {
    if (!map.attributionControl._esriAttributionAddedOnce) {
      const hoverAttributionStyle = document.createElement("style");
      hoverAttributionStyle.type = "text/css";
      hoverAttributionStyle.innerHTML = ".esri-truncated-attribution:hover {white-space: normal;}";
      document.getElementsByTagName("head")[0].appendChild(hoverAttributionStyle);
      const attributionStyle = document.createElement("style");
      attributionStyle.type = "text/css";
      attributionStyle.innerHTML = `.esri-truncated-attribution {vertical-align: -3px;white-space: nowrap;overflow: hidden;text-overflow: ellipsis;display: inline-block;transition: 0s white-space;transition-delay: 1s;max-width: ${calcAttributionWidth(map)};}`;
      document.getElementsByTagName("head")[0].appendChild(attributionStyle);
      map.on("resize", (e) => {
        if (map.attributionControl) {
          map.attributionControl._container.style.maxWidth = calcAttributionWidth(e.target);
        }
      });
      map.attributionControl._esriAttributionAddedOnce = true;
    }
    import_leaflet2.DomUtil.addClass(
      map.attributionControl._container,
      "esri-truncated-attribution:hover"
    );
    import_leaflet2.DomUtil.addClass(
      map.attributionControl._container,
      "esri-truncated-attribution"
    );
  }
  map.attributionControl._esriAttributionLayerCount = map.attributionControl._esriAttributionLayerCount + 1;
}
function getEsriAttributionHtmlString() {
  return POWERED_BY_ESRI_ATTRIBUTION_STRING;
}
function removeEsriAttribution(map) {
  if (!map.attributionControl) {
    return;
  }
  if (map.attributionControl._esriAttributionLayerCount && map.attributionControl._esriAttributionLayerCount === 1) {
    import_leaflet2.DomUtil.removeClass(
      map.attributionControl._container,
      "esri-truncated-attribution:hover"
    );
    import_leaflet2.DomUtil.removeClass(
      map.attributionControl._container,
      "esri-truncated-attribution"
    );
  }
  map.attributionControl._esriAttributionLayerCount = map.attributionControl._esriAttributionLayerCount - 1;
}
function _setGeometry(geometry) {
  const params = {
    geometry: null,
    geometryType: null
  };
  if (geometry instanceof import_leaflet2.LatLngBounds) {
    params.geometry = boundsToExtent(geometry);
    params.geometryType = "esriGeometryEnvelope";
    return params;
  }
  if (geometry.getLatLng) {
    geometry = geometry.getLatLng();
  }
  if (geometry instanceof import_leaflet2.LatLng) {
    geometry = {
      type: "Point",
      coordinates: [geometry.lng, geometry.lat]
    };
  }
  if (geometry instanceof import_leaflet2.GeoJSON) {
    geometry = geometry.getLayers()[0].feature.geometry;
    params.geometry = geojsonToArcGIS3(geometry);
    params.geometryType = geojsonTypeToArcGIS(geometry.type);
  }
  if (geometry.toGeoJSON) {
    geometry = geometry.toGeoJSON();
  }
  if (geometry.type === "Feature") {
    geometry = geometry.geometry;
  }
  if (geometry.type === "Point" || geometry.type === "LineString" || geometry.type === "Polygon" || geometry.type === "MultiPolygon") {
    params.geometry = geojsonToArcGIS3(geometry);
    params.geometryType = geojsonTypeToArcGIS(geometry.type);
    return params;
  }
  warn(
    "invalid geometry passed to spatial query. Should be L.LatLng, L.LatLngBounds, L.Marker or a GeoJSON Point, Line, Polygon or MultiPolygon object"
  );
}
function _getAttributionData(url, map) {
  if (Support.cors) {
    request(
      url,
      {},
      import_leaflet2.Util.bind((error, attributions) => {
        if (error) {
          return;
        }
        map._esriAttributions = [];
        for (let c = 0; c < attributions.contributors.length; c++) {
          const contributor = attributions.contributors[c];
          for (let i = 0; i < contributor.coverageAreas.length; i++) {
            const coverageArea = contributor.coverageAreas[i];
            const southWest = (0, import_leaflet2.latLng)(
              coverageArea.bbox[0],
              coverageArea.bbox[1]
            );
            const northEast = (0, import_leaflet2.latLng)(
              coverageArea.bbox[2],
              coverageArea.bbox[3]
            );
            map._esriAttributions.push({
              attribution: contributor.attribution,
              score: coverageArea.score,
              bounds: (0, import_leaflet2.latLngBounds)(southWest, northEast),
              minZoom: coverageArea.zoomMin,
              maxZoom: coverageArea.zoomMax
            });
          }
        }
        map._esriAttributions.sort((a, b) => b.score - a.score);
        const obj = { target: map };
        _updateMapAttribution(obj);
      }, this)
    );
  }
}
function _updateMapAttribution(evt) {
  const map = evt.target;
  const oldAttributions = map._esriAttributions;
  if (!map || !map.attributionControl) {
    return;
  }
  const attributionElement = map.attributionControl._container.querySelector(
    ".esri-dynamic-attribution"
  );
  if (attributionElement && oldAttributions) {
    let newAttributions = "";
    const bounds2 = map.getBounds();
    const wrappedBounds = (0, import_leaflet2.latLngBounds)(
      bounds2.getSouthWest().wrap(),
      bounds2.getNorthEast().wrap()
    );
    const zoom = map.getZoom();
    for (let i = 0; i < oldAttributions.length; i++) {
      const attribution = oldAttributions[i];
      const text = attribution.attribution;
      if (!newAttributions.match(text) && attribution.bounds.intersects(wrappedBounds) && zoom >= attribution.minZoom && zoom <= attribution.maxZoom) {
        newAttributions += `, ${text}`;
      }
    }
    newAttributions = `${getEsriAttributionHtmlString()} | ${newAttributions.substr(2)}`;
    attributionElement.innerHTML = newAttributions;
    attributionElement.style.maxWidth = calcAttributionWidth(map);
    map.fire("attributionupdated", {
      attribution: newAttributions
    });
  }
}
var EsriUtil = {
  warn,
  cleanUrl,
  getUrlParams,
  isArcgisOnline,
  geojsonTypeToArcGIS,
  responseToFeatureCollection,
  geojsonToArcGIS: geojsonToArcGIS3,
  arcgisToGeoJSON: arcgisToGeoJSON3,
  boundsToExtent,
  extentToBounds,
  calcAttributionWidth,
  setEsriAttribution,
  getEsriAttributionHtmlString,
  removeEsriAttribution,
  _setGeometry,
  _getAttributionData,
  _updateMapAttribution,
  _findIdAttributeFromFeature,
  _findIdAttributeFromResponse
};

// node_modules/esri-leaflet/src/Tasks/Task.js
var import_leaflet3 = __toESM(require_leaflet_src());
var Task = import_leaflet3.Class.extend({
  options: {
    proxy: false,
    useCors: cors
  },
  // Generate a method for each methodName:paramName in the setters for this task.
  generateSetter(param, context) {
    return import_leaflet3.Util.bind(function(value) {
      this.params[param] = value;
      return this;
    }, context);
  },
  initialize(endpoint) {
    if (endpoint.request && endpoint.options) {
      this._service = endpoint;
      import_leaflet3.Util.setOptions(this, endpoint.options);
    } else {
      import_leaflet3.Util.setOptions(this, endpoint);
      this.options.url = cleanUrl(endpoint.url);
    }
    this.params = import_leaflet3.Util.extend({}, this.params || {});
    if (this.setters) {
      for (const setter in this.setters) {
        const param = this.setters[setter];
        this[setter] = this.generateSetter(param, this);
      }
    }
  },
  token(token) {
    if (this._service) {
      this._service.authenticate(token);
    } else {
      this.params.token = token;
    }
    return this;
  },
  apikey(apikey) {
    return this.token(apikey);
  },
  // ArcGIS Server Find/Identify 10.5+
  format(boolean) {
    this.params.returnUnformattedValues = !boolean;
    return this;
  },
  request(callback, context) {
    if (this.options.requestParams) {
      import_leaflet3.Util.extend(this.params, this.options.requestParams);
    }
    if (this._service) {
      return this._service.request(this.path, this.params, callback, context);
    }
    return this._request("request", this.path, this.params, callback, context);
  },
  _request(method, path, params, callback, context) {
    const url = this.options.proxy ? `${this.options.proxy}?${this.options.url}${path}` : this.options.url + path;
    if ((method === "get" || method === "request") && !this.options.useCors) {
      return Request_default.get.JSONP(url, params, callback, context);
    }
    return Request_default[method](url, params, callback, context);
  }
});
function task(options2) {
  options2 = getUrlParams(options2);
  return new Task(options2);
}

// node_modules/esri-leaflet/src/Tasks/Query.js
var import_leaflet4 = __toESM(require_leaflet_src());
var Query = Task.extend({
  setters: {
    offset: "resultOffset",
    limit: "resultRecordCount",
    fields: "outFields",
    precision: "geometryPrecision",
    featureIds: "objectIds",
    returnGeometry: "returnGeometry",
    returnM: "returnM",
    transform: "datumTransformation",
    token: "token"
  },
  path: "query",
  params: {
    returnGeometry: true,
    where: "1=1",
    outSR: 4326,
    outFields: "*"
  },
  // Returns a feature if its shape is wholly contained within the search geometry. Valid for all shape type combinations.
  within(geometry) {
    this._setGeometryParams(geometry);
    this.params.spatialRel = "esriSpatialRelContains";
    return this;
  },
  // Returns a feature if any spatial relationship is found. Applies to all shape type combinations.
  intersects(geometry) {
    this._setGeometryParams(geometry);
    this.params.spatialRel = "esriSpatialRelIntersects";
    return this;
  },
  // Returns a feature if its shape wholly contains the search geometry. Valid for all shape type combinations.
  contains(geometry) {
    this._setGeometryParams(geometry);
    this.params.spatialRel = "esriSpatialRelWithin";
    return this;
  },
  // Returns a feature if the intersection of the interiors of the two shapes is not empty and has a lower dimension than the maximum dimension of the two shapes. Two lines that share an endpoint in common do not cross. Valid for Line/Line, Line/Area, Multi-point/Area, and Multi-point/Line shape type combinations.
  crosses(geometry) {
    this._setGeometryParams(geometry);
    this.params.spatialRel = "esriSpatialRelCrosses";
    return this;
  },
  // Returns a feature if the two shapes share a common boundary. However, the intersection of the interiors of the two shapes must be empty. In the Point/Line case, the point may touch an endpoint only of the line. Applies to all combinations except Point/Point.
  touches(geometry) {
    this._setGeometryParams(geometry);
    this.params.spatialRel = "esriSpatialRelTouches";
    return this;
  },
  // Returns a feature if the intersection of the two shapes results in an object of the same dimension, but different from both of the shapes. Applies to Area/Area, Line/Line, and Multi-point/Multi-point shape type combinations.
  overlaps(geometry) {
    this._setGeometryParams(geometry);
    this.params.spatialRel = "esriSpatialRelOverlaps";
    return this;
  },
  // Returns a feature if the envelope of the two shapes intersects.
  bboxIntersects(geometry) {
    this._setGeometryParams(geometry);
    this.params.spatialRel = "esriSpatialRelEnvelopeIntersects";
    return this;
  },
  // if someone can help decipher the ArcObjects explanation and translate to plain speak, we should mention this method in the doc
  indexIntersects(geometry) {
    this._setGeometryParams(geometry);
    this.params.spatialRel = "esriSpatialRelIndexIntersects";
    return this;
  },
  // only valid for Feature Services running on ArcGIS Server 10.3+ or ArcGIS Online
  nearby(latlng, radius) {
    latlng = (0, import_leaflet4.latLng)(latlng);
    this.params.geometry = [latlng.lng, latlng.lat];
    this.params.geometryType = "esriGeometryPoint";
    this.params.spatialRel = "esriSpatialRelIntersects";
    this.params.units = "esriSRUnit_Meter";
    this.params.distance = radius;
    this.params.inSR = 4326;
    return this;
  },
  where(string) {
    this.params.where = string;
    return this;
  },
  between(start, end) {
    this.params.time = [start.valueOf(), end.valueOf()];
    return this;
  },
  simplify(map, factor) {
    const mapWidth = Math.abs(
      map.getBounds().getWest() - map.getBounds().getEast()
    );
    this.params.maxAllowableOffset = mapWidth / map.getSize().y * factor;
    return this;
  },
  orderBy(fieldName, order) {
    order = order || "ASC";
    this.params.orderByFields = this.params.orderByFields ? `${this.params.orderByFields},` : "";
    this.params.orderByFields += [fieldName, order].join(" ");
    return this;
  },
  run(callback, context) {
    this._cleanParams();
    if (this.options.isModern || isArcgisOnline(this.options.url) && this.options.isModern === void 0) {
      this.params.f = "geojson";
      return this.request(function(error, response) {
        this._trapSQLerrors(error);
        callback.call(context, error, response, response);
      }, this);
    }
    return this.request(function(error, response) {
      this._trapSQLerrors(error);
      callback.call(
        context,
        error,
        response && responseToFeatureCollection(response),
        response
      );
    }, this);
  },
  count(callback, context) {
    this._cleanParams();
    this.params.returnCountOnly = true;
    return this.request(function(error, response) {
      callback.call(this, error, response && response.count, response);
    }, context);
  },
  ids(callback, context) {
    this._cleanParams();
    this.params.returnIdsOnly = true;
    return this.request(function(error, response) {
      callback.call(this, error, response && response.objectIds, response);
    }, context);
  },
  // only valid for Feature Services running on ArcGIS Server 10.3+ or ArcGIS Online
  bounds(callback, context) {
    this._cleanParams();
    this.params.returnExtentOnly = true;
    return this.request((error, response) => {
      if (response && response.extent && extentToBounds(response.extent)) {
        callback.call(
          context,
          error,
          extentToBounds(response.extent),
          response
        );
      } else {
        error = {
          message: "Invalid Bounds"
        };
        callback.call(context, error, null, response);
      }
    }, context);
  },
  distinct() {
    this.params.returnGeometry = false;
    this.params.returnDistinctValues = true;
    return this;
  },
  // only valid for image services
  pixelSize(rawPoint) {
    const castPoint = (0, import_leaflet4.point)(rawPoint);
    this.params.pixelSize = [castPoint.x, castPoint.y];
    return this;
  },
  // only valid for map services
  layer(layer) {
    this.path = `${layer}/query`;
    return this;
  },
  _trapSQLerrors(error) {
    if (error) {
      if (error.code === "400") {
        warn(
          "one common syntax error in query requests is encasing string values in double quotes instead of single quotes"
        );
      }
    }
  },
  _cleanParams() {
    delete this.params.returnIdsOnly;
    delete this.params.returnExtentOnly;
    delete this.params.returnCountOnly;
  },
  _setGeometryParams(geometry) {
    this.params.inSR = 4326;
    const converted = _setGeometry(geometry);
    this.params.geometry = converted.geometry;
    this.params.geometryType = converted.geometryType;
  }
});
function query(options2) {
  return new Query(options2);
}
var Query_default = query;

// node_modules/esri-leaflet/src/Tasks/Find.js
var Find = Task.extend({
  setters: {
    // method name > param name
    contains: "contains",
    text: "searchText",
    fields: "searchFields",
    // denote an array or single string
    spatialReference: "sr",
    sr: "sr",
    layers: "layers",
    returnGeometry: "returnGeometry",
    maxAllowableOffset: "maxAllowableOffset",
    precision: "geometryPrecision",
    dynamicLayers: "dynamicLayers",
    returnZ: "returnZ",
    returnM: "returnM",
    gdbVersion: "gdbVersion",
    // skipped implementing this (for now) because the REST service implementation isnt consistent between operations
    // 'transform': 'datumTransformations',
    token: "token"
  },
  path: "find",
  params: {
    sr: 4326,
    contains: true,
    returnGeometry: true,
    returnZ: true,
    returnM: false
  },
  layerDefs(id, where) {
    this.params.layerDefs = this.params.layerDefs ? `${this.params.layerDefs};` : "";
    this.params.layerDefs += [id, where].join(":");
    return this;
  },
  simplify(map, factor) {
    const mapWidth = Math.abs(
      map.getBounds().getWest() - map.getBounds().getEast()
    );
    this.params.maxAllowableOffset = mapWidth / map.getSize().y * factor;
    return this;
  },
  run(callback, context) {
    return this.request((error, response) => {
      callback.call(
        context,
        error,
        response && responseToFeatureCollection(response),
        response
      );
    }, context);
  }
});
function find(options2) {
  return new Find(options2);
}
var Find_default = find;

// node_modules/esri-leaflet/src/Tasks/Identify.js
var Identify = Task.extend({
  path: "identify",
  between(start, end) {
    this.params.time = [start.valueOf(), end.valueOf()];
    return this;
  }
});
function identify(options2) {
  return new Identify(options2);
}

// node_modules/esri-leaflet/src/Tasks/IdentifyFeatures.js
var import_leaflet5 = __toESM(require_leaflet_src());
var IdentifyFeatures = Identify.extend({
  setters: {
    layers: "layers",
    precision: "geometryPrecision",
    tolerance: "tolerance",
    // skipped implementing this (for now) because the REST service implementation isnt consistent between operations.
    // 'transform': 'datumTransformations'
    returnGeometry: "returnGeometry"
  },
  params: {
    sr: 4326,
    layers: "all",
    tolerance: 3,
    returnGeometry: true
  },
  on(map) {
    const extent = boundsToExtent(map.getBounds());
    const size = map.getSize();
    this.params.imageDisplay = [size.x, size.y, 96];
    this.params.mapExtent = [
      extent.xmin,
      extent.ymin,
      extent.xmax,
      extent.ymax
    ];
    return this;
  },
  at(geometry) {
    if (geometry.length === 2) {
      geometry = (0, import_leaflet5.latLng)(geometry);
    }
    this._setGeometryParams(geometry);
    return this;
  },
  layerDef(id, where) {
    this.params.layerDefs = this.params.layerDefs ? `${this.params.layerDefs};` : "";
    this.params.layerDefs += [id, where].join(":");
    return this;
  },
  simplify(map, factor) {
    const mapWidth = Math.abs(
      map.getBounds().getWest() - map.getBounds().getEast()
    );
    this.params.maxAllowableOffset = mapWidth / map.getSize().y * factor;
    return this;
  },
  run(callback, context) {
    return this.request((error, response) => {
      if (error) {
        callback.call(context, error, void 0, response);
      } else {
        const featureCollection = responseToFeatureCollection(response);
        response.results = response.results.reverse();
        for (let i = 0; i < featureCollection.features.length; i++) {
          const feature = featureCollection.features[i];
          feature.layerId = response.results[i].layerId;
        }
        callback.call(context, void 0, featureCollection, response);
      }
    });
  },
  _setGeometryParams(geometry) {
    const converted = _setGeometry(geometry);
    this.params.geometry = converted.geometry;
    this.params.geometryType = converted.geometryType;
  }
});
function identifyFeatures(options2) {
  return new IdentifyFeatures(options2);
}
var IdentifyFeatures_default = identifyFeatures;

// node_modules/esri-leaflet/src/Tasks/IdentifyImage.js
var import_leaflet6 = __toESM(require_leaflet_src());
var IdentifyImage = Identify.extend({
  setters: {
    setMosaicRule: "mosaicRule",
    setRenderingRule: "renderingRule",
    setPixelSize: "pixelSize",
    returnCatalogItems: "returnCatalogItems",
    returnGeometry: "returnGeometry"
  },
  params: {
    returnGeometry: false
  },
  at(latlng) {
    latlng = (0, import_leaflet6.latLng)(latlng);
    this.params.geometry = JSON.stringify({
      x: latlng.lng,
      y: latlng.lat,
      spatialReference: {
        wkid: 4326
      }
    });
    this.params.geometryType = "esriGeometryPoint";
    return this;
  },
  getMosaicRule() {
    return this.params.mosaicRule;
  },
  getRenderingRule() {
    return this.params.renderingRule;
  },
  getPixelSize() {
    return this.params.pixelSize;
  },
  run(callback, context) {
    return this.request(function(error, response) {
      callback.call(
        context,
        error,
        response && this._responseToGeoJSON(response),
        response
      );
    }, this);
  },
  // get pixel data and return as geoJSON point
  // populate catalog items (if any)
  // merging in any catalogItemVisibilities as a propery of each feature
  _responseToGeoJSON(response) {
    const location = response.location;
    const catalogItems = response.catalogItems;
    const catalogItemVisibilities = response.catalogItemVisibilities;
    const geoJSON = {
      pixel: {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: [location.x, location.y]
        },
        crs: {
          type: "EPSG",
          properties: {
            code: location.spatialReference.wkid
          }
        },
        properties: {
          OBJECTID: response.objectId,
          name: response.name,
          value: response.value
        },
        id: response.objectId
      }
    };
    if (response.properties && response.properties.Values) {
      geoJSON.pixel.properties.values = response.properties.Values;
    }
    if (catalogItems && catalogItems.features) {
      geoJSON.catalogItems = responseToFeatureCollection(catalogItems);
      if (catalogItemVisibilities && catalogItemVisibilities.length === geoJSON.catalogItems.features.length) {
        for (let i = catalogItemVisibilities.length - 1; i >= 0; i--) {
          geoJSON.catalogItems.features[i].properties.catalogItemVisibility = catalogItemVisibilities[i];
        }
      }
    }
    return geoJSON;
  }
});
function identifyImage(params) {
  return new IdentifyImage(params);
}
var IdentifyImage_default = identifyImage;

// node_modules/esri-leaflet/src/Services/Service.js
var import_leaflet7 = __toESM(require_leaflet_src());
var Service = import_leaflet7.Evented.extend({
  options: {
    proxy: false,
    useCors: cors,
    timeout: 0
  },
  initialize(options2) {
    options2 = options2 || {};
    this._requestQueue = [];
    this._authenticating = false;
    import_leaflet7.Util.setOptions(this, options2);
    this.options.url = cleanUrl(this.options.url);
  },
  get(path, params, callback, context) {
    return this._request("get", path, params, callback, context);
  },
  post(path, params, callback, context) {
    return this._request("post", path, params, callback, context);
  },
  request(path, params, callback, context) {
    return this._request("request", path, params, callback, context);
  },
  metadata(callback, context) {
    return this._request("get", "", {}, callback, context);
  },
  authenticate(token) {
    this._authenticating = false;
    this.options.token = token;
    this._runQueue();
    return this;
  },
  getTimeout() {
    return this.options.timeout;
  },
  setTimeout(timeout) {
    this.options.timeout = timeout;
  },
  _request(method, path, params, callback, context) {
    this.fire(
      "requeststart",
      {
        url: this.options.url + path,
        params,
        method
      },
      true
    );
    const wrappedCallback = this._createServiceCallback(
      method,
      path,
      params,
      callback,
      context
    );
    if (this.options.token) {
      params.token = this.options.token;
    }
    if (this.options.requestParams) {
      import_leaflet7.Util.extend(params, this.options.requestParams);
    }
    if (this._authenticating) {
      this._requestQueue.push([method, path, params, callback, context]);
    } else {
      const url = this.options.proxy ? `${this.options.proxy}?${this.options.url}${path}` : this.options.url + path;
      if ((method === "get" || method === "request") && !this.options.useCors) {
        return Request_default.get.JSONP(url, params, wrappedCallback, context);
      }
      return Request_default[method](url, params, wrappedCallback, context);
    }
  },
  _createServiceCallback(method, path, params, callback, context) {
    return import_leaflet7.Util.bind(function(error, response) {
      if (error && (error.code === 499 || error.code === 498)) {
        this._authenticating = true;
        this._requestQueue.push([method, path, params, callback, context]);
        this.fire(
          "authenticationrequired",
          {
            authenticate: import_leaflet7.Util.bind(this.authenticate, this)
          },
          true
        );
        error.authenticate = import_leaflet7.Util.bind(this.authenticate, this);
      }
      callback.call(context, error, response);
      if (error) {
        this.fire(
          "requesterror",
          {
            url: this.options.url + path,
            params,
            message: error.message,
            code: error.code,
            method
          },
          true
        );
      } else {
        this.fire(
          "requestsuccess",
          {
            url: this.options.url + path,
            params,
            response,
            method
          },
          true
        );
      }
      this.fire(
        "requestend",
        {
          url: this.options.url + path,
          params,
          method
        },
        true
      );
    }, this);
  },
  _runQueue() {
    for (let i = this._requestQueue.length - 1; i >= 0; i--) {
      const request2 = this._requestQueue[i];
      const method = request2.shift();
      this[method].apply(this, request2);
    }
    this._requestQueue = [];
  }
});
function service(options2) {
  options2 = getUrlParams(options2);
  return new Service(options2);
}

// node_modules/esri-leaflet/src/Services/MapService.js
var MapService = Service.extend({
  identify() {
    return IdentifyFeatures_default(this);
  },
  find() {
    return Find_default(this);
  },
  query() {
    return Query_default(this);
  }
});
function mapService(options2) {
  return new MapService(options2);
}
var MapService_default = mapService;

// node_modules/esri-leaflet/src/Services/ImageService.js
var ImageService = Service.extend({
  query() {
    return Query_default(this);
  },
  identify() {
    return IdentifyImage_default(this);
  }
});
function imageService(options2) {
  return new ImageService(options2);
}
var ImageService_default = imageService;

// node_modules/esri-leaflet/src/Services/FeatureLayerService.js
var FeatureLayerService = Service.extend({
  options: {
    idAttribute: "OBJECTID"
  },
  query() {
    return Query_default(this);
  },
  addFeature(feature, callback, context) {
    this.addFeatures(feature, callback, context);
  },
  addFeatures(features, callback, context) {
    const featuresArray = features.features ? features.features : [features];
    for (let i = featuresArray.length - 1; i >= 0; i--) {
      delete featuresArray[i].id;
    }
    features = geojsonToArcGIS3(features);
    features = featuresArray.length > 1 ? features : [features];
    return this.post(
      "addFeatures",
      {
        features
      },
      (error, response) => {
        const result = response && response.addResults ? response.addResults.length > 1 ? response.addResults : response.addResults[0] : void 0;
        if (callback) {
          callback.call(context, error || response.addResults[0].error, result);
        }
      },
      context
    );
  },
  updateFeature(feature, callback, context) {
    this.updateFeatures(feature, callback, context);
  },
  updateFeatures(features, callback, context) {
    const featuresArray = features.features ? features.features : [features];
    features = geojsonToArcGIS3(features, this.options.idAttribute);
    features = featuresArray.length > 1 ? features : [features];
    return this.post(
      "updateFeatures",
      {
        features
      },
      (error, response) => {
        const result = response && response.updateResults ? response.updateResults.length > 1 ? response.updateResults : response.updateResults[0] : void 0;
        if (callback) {
          callback.call(
            context,
            error || response.updateResults[0].error,
            result
          );
        }
      },
      context
    );
  },
  deleteFeature(id, callback, context) {
    this.deleteFeatures(id, callback, context);
  },
  deleteFeatures(ids, callback, context) {
    return this.post(
      "deleteFeatures",
      {
        objectIds: ids
      },
      (error, response) => {
        const result = response && response.deleteResults ? response.deleteResults.length > 1 ? response.deleteResults : response.deleteResults[0] : void 0;
        if (callback) {
          callback.call(
            context,
            error || response.deleteResults[0].error,
            result
          );
        }
      },
      context
    );
  }
});
function featureLayerService(options2) {
  return new FeatureLayerService(options2);
}
var FeatureLayerService_default = featureLayerService;

// node_modules/esri-leaflet/src/Layers/BasemapLayer.js
var import_leaflet8 = __toESM(require_leaflet_src());
var tileProtocol = window.location.protocol !== "https:" ? "http:" : "https:";
var BasemapLayer = import_leaflet8.TileLayer.extend({
  statics: {
    TILES: {
      Streets: {
        urlTemplate: `${tileProtocol}//{s}.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}`,
        options: {
          minZoom: 1,
          maxZoom: 19,
          subdomains: ["server", "services"],
          attribution: "USGS, NOAA",
          attributionUrl: "https://static.arcgis.com/attribution/World_Street_Map"
        }
      },
      Topographic: {
        urlTemplate: `${tileProtocol}//{s}.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}`,
        options: {
          minZoom: 1,
          maxZoom: 19,
          subdomains: ["server", "services"],
          attribution: "USGS, NOAA",
          attributionUrl: "https://static.arcgis.com/attribution/World_Topo_Map"
        }
      },
      Oceans: {
        urlTemplate: `${tileProtocol}//{s}.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Base/MapServer/tile/{z}/{y}/{x}`,
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ["server", "services"],
          attribution: "USGS, NOAA",
          attributionUrl: "https://static.arcgis.com/attribution/Ocean_Basemap"
        }
      },
      OceansLabels: {
        urlTemplate: `${tileProtocol}//{s}.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Reference/MapServer/tile/{z}/{y}/{x}`,
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ["server", "services"],
          pane: pointerEvents ? "esri-labels" : "tilePane",
          attribution: ""
        }
      },
      NationalGeographic: {
        urlTemplate: `${tileProtocol}//{s}.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}`,
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ["server", "services"],
          attribution: "National Geographic, DeLorme, HERE, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, increment P Corp."
        }
      },
      DarkGray: {
        urlTemplate: `${tileProtocol}//{s}.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Base/MapServer/tile/{z}/{y}/{x}`,
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ["server", "services"],
          attribution: "HERE, DeLorme, MapmyIndia, &copy; OpenStreetMap contributors"
        }
      },
      DarkGrayLabels: {
        urlTemplate: `${tileProtocol}//{s}.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Reference/MapServer/tile/{z}/{y}/{x}`,
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ["server", "services"],
          pane: pointerEvents ? "esri-labels" : "tilePane",
          attribution: ""
        }
      },
      Gray: {
        urlTemplate: `${tileProtocol}//{s}.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}`,
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ["server", "services"],
          attribution: "HERE, DeLorme, MapmyIndia, &copy; OpenStreetMap contributors"
        }
      },
      GrayLabels: {
        urlTemplate: `${tileProtocol}//{s}.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Reference/MapServer/tile/{z}/{y}/{x}`,
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ["server", "services"],
          pane: pointerEvents ? "esri-labels" : "tilePane",
          attribution: ""
        }
      },
      Imagery: {
        urlTemplate: `${tileProtocol}//{s}.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}`,
        options: {
          minZoom: 1,
          maxZoom: 19,
          subdomains: ["server", "services"],
          attribution: "DigitalGlobe, GeoEye, i-cubed, USDA, USGS, AEX, Getmapping, Aerogrid, IGN, IGP, swisstopo, and the GIS User Community",
          attributionUrl: "https://static.arcgis.com/attribution/World_Imagery"
        }
      },
      ImageryLabels: {
        urlTemplate: `${tileProtocol}//{s}.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}`,
        options: {
          minZoom: 1,
          maxZoom: 19,
          subdomains: ["server", "services"],
          pane: pointerEvents ? "esri-labels" : "tilePane",
          attribution: ""
        }
      },
      ImageryTransportation: {
        urlTemplate: `${tileProtocol}//{s}.arcgisonline.com/ArcGIS/rest/services/Reference/World_Transportation/MapServer/tile/{z}/{y}/{x}`,
        options: {
          minZoom: 1,
          maxZoom: 19,
          subdomains: ["server", "services"],
          pane: pointerEvents ? "esri-labels" : "tilePane",
          attribution: ""
        }
      },
      ShadedRelief: {
        urlTemplate: `${tileProtocol}//{s}.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}`,
        options: {
          minZoom: 1,
          maxZoom: 13,
          subdomains: ["server", "services"],
          attribution: "USGS"
        }
      },
      ShadedReliefLabels: {
        urlTemplate: `${tileProtocol}//{s}.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places_Alternate/MapServer/tile/{z}/{y}/{x}`,
        options: {
          minZoom: 1,
          maxZoom: 12,
          subdomains: ["server", "services"],
          pane: pointerEvents ? "esri-labels" : "tilePane",
          attribution: ""
        }
      },
      Terrain: {
        urlTemplate: `${tileProtocol}//{s}.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}`,
        options: {
          minZoom: 1,
          maxZoom: 13,
          subdomains: ["server", "services"],
          attribution: "USGS, NOAA"
        }
      },
      TerrainLabels: {
        urlTemplate: `${tileProtocol}//{s}.arcgisonline.com/ArcGIS/rest/services/Reference/World_Reference_Overlay/MapServer/tile/{z}/{y}/{x}`,
        options: {
          minZoom: 1,
          maxZoom: 13,
          subdomains: ["server", "services"],
          pane: pointerEvents ? "esri-labels" : "tilePane",
          attribution: ""
        }
      },
      USATopo: {
        urlTemplate: `${tileProtocol}//{s}.arcgisonline.com/ArcGIS/rest/services/USA_Topo_Maps/MapServer/tile/{z}/{y}/{x}`,
        options: {
          minZoom: 1,
          maxZoom: 15,
          subdomains: ["server", "services"],
          attribution: "USGS, National Geographic Society, i-cubed"
        }
      },
      ImageryClarity: {
        urlTemplate: `${tileProtocol}//clarity.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}`,
        options: {
          minZoom: 1,
          maxZoom: 19,
          attribution: "Esri, DigitalGlobe, GeoEye, Earthstar Geographics, CNES/Airbus DS, USDA, USGS, AeroGRID, IGN, and the GIS User Community"
        }
      },
      Physical: {
        urlTemplate: `${tileProtocol}//{s}.arcgisonline.com/arcgis/rest/services/World_Physical_Map/MapServer/tile/{z}/{y}/{x}`,
        options: {
          minZoom: 1,
          maxZoom: 8,
          subdomains: ["server", "services"],
          attribution: "U.S. National Park Service"
        }
      },
      ImageryFirefly: {
        urlTemplate: `${tileProtocol}//fly.maptiles.arcgis.com/arcgis/rest/services/World_Imagery_Firefly/MapServer/tile/{z}/{y}/{x}`,
        options: {
          minZoom: 1,
          maxZoom: 19,
          attribution: "Esri, DigitalGlobe, GeoEye, Earthstar Geographics, CNES/Airbus DS, USDA, USGS, AeroGRID, IGN, and the GIS User Community",
          attributionUrl: "https://static.arcgis.com/attribution/World_Imagery"
        }
      }
    }
  },
  initialize(key, options2) {
    let config;
    if (typeof key === "object" && key.urlTemplate && key.options) {
      config = key;
    } else if (typeof key === "string" && BasemapLayer.TILES[key]) {
      config = BasemapLayer.TILES[key];
    } else {
      throw new Error(
        'L.esri.BasemapLayer: Invalid parameter. Use one of "Streets", "Topographic", "Oceans", "OceansLabels", "NationalGeographic", "Physical", "Gray", "GrayLabels", "DarkGray", "DarkGrayLabels", "Imagery", "ImageryLabels", "ImageryTransportation", "ImageryClarity", "ImageryFirefly", ShadedRelief", "ShadedReliefLabels", "Terrain", "TerrainLabels" or "USATopo"'
      );
    }
    const tileOptions = import_leaflet8.Util.extend(config.options, options2);
    import_leaflet8.Util.setOptions(this, tileOptions);
    if (!this.options.ignoreDeprecationWarning) {
      console.warn(
        "WARNING: L.esri.BasemapLayer uses data services that are in mature support and are not being updated. Please use L.esri.Vector.vectorBasemapLayer instead. More info: https://esriurl.com/esri-leaflet-basemap"
      );
    }
    if (this.options.token && config.urlTemplate.indexOf("token=") === -1) {
      config.urlTemplate += `?token=${this.options.token}`;
    }
    if (this.options.proxy) {
      config.urlTemplate = `${this.options.proxy}?${config.urlTemplate}`;
    }
    import_leaflet8.TileLayer.prototype.initialize.call(this, config.urlTemplate, tileOptions);
  },
  onAdd(map) {
    setEsriAttribution(map);
    if (this.options.pane === "esri-labels") {
      this._initPane();
    }
    if (this.options.attributionUrl) {
      _getAttributionData(
        (this.options.proxy ? `${this.options.proxy}?` : "") + this.options.attributionUrl,
        map
      );
    }
    map.on("moveend", _updateMapAttribution);
    import_leaflet8.TileLayer.prototype.onAdd.call(this, map);
  },
  onRemove(map) {
    removeEsriAttribution(map);
    map.off("moveend", _updateMapAttribution);
    import_leaflet8.TileLayer.prototype.onRemove.call(this, map);
  },
  _initPane() {
    if (!this._map.getPane(this.options.pane)) {
      const pane = this._map.createPane(this.options.pane);
      pane.style.pointerEvents = "none";
      pane.style.zIndex = 500;
    }
  },
  getAttribution() {
    let attribution;
    if (this.options.attribution) {
      attribution = `<span class="esri-dynamic-attribution">${this.options.attribution}</span>`;
    }
    return attribution;
  }
});
function basemapLayer(key, options2) {
  return new BasemapLayer(key, options2);
}

// node_modules/esri-leaflet/src/Layers/TiledMapLayer.js
var import_leaflet9 = __toESM(require_leaflet_src());
var TiledMapLayer = import_leaflet9.TileLayer.extend({
  options: {
    zoomOffsetAllowance: 0.1,
    errorTileUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEABAMAAACuXLVVAAAAA1BMVEUzNDVszlHHAAAAAXRSTlMAQObYZgAAAAlwSFlzAAAAAAAAAAAB6mUWpAAAADZJREFUeJztwQEBAAAAgiD/r25IQAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7waBAAABw08RwAAAAABJRU5ErkJggg=="
  },
  statics: {
    MercatorZoomLevels: {
      0: 156543.033928,
      1: 78271.5169639999,
      2: 39135.7584820001,
      3: 19567.8792409999,
      4: 9783.93962049996,
      5: 4891.96981024998,
      6: 2445.98490512499,
      7: 1222.99245256249,
      8: 611.49622628138,
      9: 305.748113140558,
      10: 152.874056570411,
      11: 76.4370282850732,
      12: 38.2185141425366,
      13: 19.1092570712683,
      14: 9.55462853563415,
      15: 4.77731426794937,
      16: 2.38865713397468,
      17: 1.19432856685505,
      18: 0.597164283559817,
      19: 0.298582141647617,
      20: 0.14929107082381,
      21: 0.07464553541191,
      22: 0.0373227677059525,
      23: 0.0186613838529763
    }
  },
  initialize(options2) {
    options2 = import_leaflet9.Util.setOptions(this, options2);
    if (options2.apikey) {
      options2.token = options2.apikey;
    }
    options2 = getUrlParams(options2);
    this.tileUrl = `${(options2.proxy ? `${options2.proxy}?` : "") + options2.url}tile/{z}/{y}/{x}${options2.requestParams && Object.keys(options2.requestParams).length > 0 ? import_leaflet9.Util.getParamString(options2.requestParams) : ""}`;
    if (options2.url.indexOf("{s}") !== -1 && options2.subdomains) {
      options2.url = options2.url.replace("{s}", options2.subdomains[0]);
    }
    this.service = MapService_default(options2);
    this.service.addEventParent(this);
    const arcgisonline = new RegExp(/tiles.arcgis(online)?\.com/g);
    if (arcgisonline.test(options2.url)) {
      this.tileUrl = this.tileUrl.replace("://tiles", "://tiles{s}");
      options2.subdomains = ["1", "2", "3", "4"];
    }
    if (this.options.token) {
      this.tileUrl += `?token=${this.options.token}`;
    }
    import_leaflet9.TileLayer.prototype.initialize.call(this, this.tileUrl, options2);
  },
  getTileUrl(tilePoint) {
    const zoom = this._getZoomForUrl();
    return import_leaflet9.Util.template(
      this.tileUrl,
      import_leaflet9.Util.extend(
        {
          s: this._getSubdomain(tilePoint),
          x: tilePoint.x,
          y: tilePoint.y,
          // try lod map first, then just default to zoom level
          z: this._lodMap && this._lodMap[zoom] !== void 0 ? this._lodMap[zoom] : zoom
        },
        this.options
      )
    );
  },
  createTile(coords, done) {
    const tile = document.createElement("img");
    import_leaflet9.DomEvent.on(tile, "load", import_leaflet9.Util.bind(this._tileOnLoad, this, done, tile));
    import_leaflet9.DomEvent.on(tile, "error", import_leaflet9.Util.bind(this._tileOnError, this, done, tile));
    if (this.options.crossOrigin) {
      tile.crossOrigin = "";
    }
    tile.alt = "";
    if (this._lodMap === "crs" || this._lodMap && this._lodMap[this._getZoomForUrl()] !== void 0) {
      tile.src = this.getTileUrl(coords);
    } else {
      this.once(
        "lodmap",
        function() {
          tile.src = this.getTileUrl(coords);
        },
        this
      );
    }
    return tile;
  },
  onAdd(map) {
    setEsriAttribution(map);
    if (!this._lodMap) {
      this.metadata(function(error, metadata) {
        if (!error && metadata.spatialReference) {
          const sr = metadata.spatialReference.latestWkid || metadata.spatialReference.wkid;
          if (!this.options.attribution && map.attributionControl && metadata.copyrightText) {
            this.options.attribution = metadata.copyrightText;
            map.attributionControl.addAttribution(this.getAttribution());
          }
          if (map.options.crs === import_leaflet9.CRS.EPSG3857 && (sr === 102100 || sr === 3857)) {
            this._lodMap = {};
            const arcgisLODs = metadata.tileInfo.lods;
            const correctResolutions = TiledMapLayer.MercatorZoomLevels;
            for (let i = 0; i < arcgisLODs.length; i++) {
              const arcgisLOD = arcgisLODs[i];
              for (const ci in correctResolutions) {
                const correctRes = correctResolutions[ci];
                if (this._withinPercentage(
                  arcgisLOD.resolution,
                  correctRes,
                  this.options.zoomOffsetAllowance
                )) {
                  this._lodMap[ci] = arcgisLOD.level;
                  break;
                }
              }
            }
            this.fire("lodmap");
          } else if (map.options.crs && map.options.crs.code && map.options.crs.code.indexOf(sr) > -1) {
            this._lodMap = "crs";
            this.fire("lodmap");
          } else {
            warn(
              "L.esri.TiledMapLayer is using a non-mercator spatial reference. Support may be available through Proj4Leaflet https://developers.arcgis.com/esri-leaflet/samples/non-mercator-projection/"
            );
          }
        }
      }, this);
    }
    import_leaflet9.TileLayer.prototype.onAdd.call(this, map);
  },
  onRemove(map) {
    removeEsriAttribution(map);
    import_leaflet9.TileLayer.prototype.onRemove.call(this, map);
  },
  metadata(callback, context) {
    this.service.metadata(callback, context);
    return this;
  },
  identify() {
    return this.service.identify();
  },
  find() {
    return this.service.find();
  },
  query() {
    return this.service.query();
  },
  authenticate(token) {
    const tokenQs = `?token=${token}`;
    this.tileUrl = this.options.token ? this.tileUrl.replace(/\?token=(.+)/g, tokenQs) : this.tileUrl + tokenQs;
    this.options.token = token;
    this.service.authenticate(token);
    return this;
  },
  _withinPercentage(a, b, percentage) {
    const diff = Math.abs(a / b - 1);
    return diff < percentage;
  }
});
function tiledMapLayer(url, options2) {
  return new TiledMapLayer(url, options2);
}

// node_modules/esri-leaflet/src/Layers/RasterLayer.js
var import_leaflet10 = __toESM(require_leaflet_src());
var Overlay = import_leaflet10.ImageOverlay.extend({
  onAdd(map) {
    this._topLeft = map.getPixelBounds().min;
    import_leaflet10.ImageOverlay.prototype.onAdd.call(this, map);
  },
  _reset() {
    if (this._map.options.crs === import_leaflet10.CRS.EPSG3857) {
      import_leaflet10.ImageOverlay.prototype._reset.call(this);
    } else {
      import_leaflet10.DomUtil.setPosition(
        this._image,
        this._topLeft.subtract(this._map.getPixelOrigin())
      );
    }
  }
});
var RasterLayer = import_leaflet10.Layer.extend({
  options: {
    opacity: 1,
    position: "front",
    f: "image",
    useCors: cors,
    attribution: null,
    interactive: false,
    alt: ""
  },
  onAdd(map) {
    setEsriAttribution(map);
    if (this.options.zIndex) {
      this.options.position = null;
    }
    this._update = import_leaflet10.Util.throttle(
      this._update,
      this.options.updateInterval,
      this
    );
    map.on("moveend", this._update, this);
    if (this._currentImage && this._currentImage._bounds.equals(this._map.getBounds())) {
      map.addLayer(this._currentImage);
    } else if (this._currentImage) {
      this._map.removeLayer(this._currentImage);
      this._currentImage = null;
    }
    this._update();
    if (this._popup) {
      this._map.on("click", this._getPopupData, this);
      this._map.on("dblclick", this._resetPopupState, this);
    }
    this.metadata(function(err, metadata) {
      if (!err && !this.options.attribution && map.attributionControl && metadata.copyrightText) {
        this.options.attribution = metadata.copyrightText;
        map.attributionControl.addAttribution(this.getAttribution());
      }
    }, this);
  },
  onRemove(map) {
    removeEsriAttribution(map);
    if (this._currentImage) {
      this._map.removeLayer(this._currentImage);
    }
    if (this._popup) {
      this._map.off("click", this._getPopupData, this);
      this._map.off("dblclick", this._resetPopupState, this);
    }
    this._map.off("moveend", this._update, this);
  },
  bindPopup(fn, popupOptions) {
    this._shouldRenderPopup = false;
    this._lastClick = false;
    this._popup = (0, import_leaflet10.popup)(popupOptions);
    this._popupFunction = fn;
    if (this._map) {
      this._map.on("click", this._getPopupData, this);
      this._map.on("dblclick", this._resetPopupState, this);
    }
    return this;
  },
  unbindPopup() {
    if (this._map) {
      this._map.closePopup(this._popup);
      this._map.off("click", this._getPopupData, this);
      this._map.off("dblclick", this._resetPopupState, this);
    }
    this._popup = false;
    return this;
  },
  bringToFront() {
    this.options.position = "front";
    if (this._currentImage) {
      this._currentImage.bringToFront();
      this._setAutoZIndex(Math.max);
    }
    return this;
  },
  bringToBack() {
    this.options.position = "back";
    if (this._currentImage) {
      this._currentImage.bringToBack();
      this._setAutoZIndex(Math.min);
    }
    return this;
  },
  setZIndex(value) {
    this.options.zIndex = value;
    if (this._currentImage) {
      this._currentImage.setZIndex(value);
    }
    return this;
  },
  _setAutoZIndex(compare) {
    if (!this._currentImage) {
      return;
    }
    const layers = this._currentImage.getPane().children;
    let edgeZIndex = -compare(-Infinity, Infinity);
    for (let i = 0, len = layers.length, zIndex; i < len; i++) {
      zIndex = layers[i].style.zIndex;
      if (layers[i] !== this._currentImage._image && zIndex) {
        edgeZIndex = compare(edgeZIndex, +zIndex);
      }
    }
    if (isFinite(edgeZIndex)) {
      this.options.zIndex = edgeZIndex + compare(-1, 1);
      this.setZIndex(this.options.zIndex);
    }
  },
  getAttribution() {
    return this.options.attribution;
  },
  getOpacity() {
    return this.options.opacity;
  },
  setOpacity(opacity) {
    this.options.opacity = opacity;
    if (this._currentImage) {
      this._currentImage.setOpacity(opacity);
    }
    return this;
  },
  getTimeRange() {
    return [this.options.from, this.options.to];
  },
  setTimeRange(from, to) {
    this.options.from = from;
    this.options.to = to;
    this._update();
    return this;
  },
  metadata(callback, context) {
    this.service.metadata(callback, context);
    return this;
  },
  authenticate(token) {
    this.service.authenticate(token);
    return this;
  },
  redraw() {
    this._update();
  },
  _renderImage(url, bounds2, contentType) {
    if (this._map) {
      if (contentType) {
        url = `data:${contentType};base64,${url}`;
      }
      if (!url) {
        return;
      }
      const image = new Overlay(url, bounds2, {
        opacity: 0,
        crossOrigin: this.options.withCredentials ? "use-credentials" : this.options.useCors,
        alt: this.options.alt,
        pane: this.options.pane || this.getPane(),
        interactive: this.options.interactive
      }).addTo(this._map);
      let onOverlayLoad;
      const onOverlayError = function() {
        this._map.removeLayer(image);
        this.fire("error");
        image.off("load", onOverlayLoad, this);
      };
      onOverlayLoad = function(e) {
        image.off("error", onOverlayError, this);
        if (this._map) {
          const newImage = e.target;
          const oldImage = this._currentImage;
          if (newImage._bounds.equals(bounds2) && newImage._bounds.equals(this._map.getBounds())) {
            this._currentImage = newImage;
            if (this.options.position === "front") {
              this.bringToFront();
            } else if (this.options.position === "back") {
              this.bringToBack();
            }
            if (this.options.zIndex) {
              this.setZIndex(this.options.zIndex);
            }
            if (this._map && this._currentImage._map) {
              this._currentImage.setOpacity(this.options.opacity);
            } else {
              this._currentImage._map.removeLayer(this._currentImage);
            }
            if (oldImage && this._map) {
              this._map.removeLayer(oldImage);
            }
            if (oldImage && oldImage._map) {
              oldImage._map.removeLayer(oldImage);
            }
          } else {
            this._map.removeLayer(newImage);
          }
        }
        this.fire("load", {
          bounds: bounds2
        });
      };
      image.once("error", onOverlayError, this);
      image.once("load", onOverlayLoad, this);
    }
  },
  _update() {
    if (!this._map) {
      return;
    }
    const zoom = this._map.getZoom();
    const bounds2 = this._map.getBounds();
    if (this._animatingZoom) {
      return;
    }
    if (this._map._panTransition && this._map._panTransition._inProgress) {
      return;
    }
    if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
      if (this._currentImage) {
        this._currentImage._map.removeLayer(this._currentImage);
        this._currentImage = null;
      }
      return;
    }
    const params = this._buildExportParams();
    import_leaflet10.Util.extend(params, this.options.requestParams);
    if (params) {
      this._requestExport(params, bounds2);
      this.fire("loading", {
        bounds: bounds2
      });
    } else if (this._currentImage) {
      this._currentImage._map.removeLayer(this._currentImage);
      this._currentImage = null;
    }
  },
  _renderPopup(latlng, error, results, response) {
    latlng = (0, import_leaflet10.latLng)(latlng);
    if (this._shouldRenderPopup && this._lastClick.equals(latlng)) {
      const content = this._popupFunction(error, results, response);
      if (content) {
        this._popup.setLatLng(latlng).setContent(content).openOn(this._map);
      }
    }
  },
  _resetPopupState(e) {
    this._shouldRenderPopup = false;
    this._lastClick = e.latlng;
  },
  _calculateBbox() {
    const pixelBounds = this._map.getPixelBounds();
    const sw = this._map.unproject(pixelBounds.getBottomLeft());
    const ne = this._map.unproject(pixelBounds.getTopRight());
    const neProjected = this._map.options.crs.project(ne);
    const swProjected = this._map.options.crs.project(sw);
    const boundsProjected = (0, import_leaflet10.bounds)(neProjected, swProjected);
    return [
      boundsProjected.getBottomLeft().x,
      boundsProjected.getBottomLeft().y,
      boundsProjected.getTopRight().x,
      boundsProjected.getTopRight().y
    ].join(",");
  },
  _calculateImageSize() {
    const bounds2 = this._map.getPixelBounds();
    const size = this._map.getSize();
    const sw = this._map.unproject(bounds2.getBottomLeft());
    const ne = this._map.unproject(bounds2.getTopRight());
    const top = this._map.latLngToLayerPoint(ne).y;
    const bottom = this._map.latLngToLayerPoint(sw).y;
    if (top > 0 || bottom < size.y) {
      size.y = bottom - top;
    }
    return `${size.x},${size.y}`;
  }
});

// node_modules/esri-leaflet/src/Layers/ImageMapLayer.js
var import_leaflet11 = __toESM(require_leaflet_src());
var ImageMapLayer = RasterLayer.extend({
  options: {
    updateInterval: 150,
    format: "jpgpng",
    transparent: true,
    f: "image"
  },
  query() {
    return this.service.query();
  },
  identify() {
    return this.service.identify();
  },
  initialize(options2) {
    options2 = getUrlParams(options2);
    this.service = ImageService_default(options2);
    this.service.addEventParent(this);
    import_leaflet11.Util.setOptions(this, options2);
  },
  setPixelType(pixelType) {
    this.options.pixelType = pixelType;
    this._update();
    return this;
  },
  getPixelType() {
    return this.options.pixelType;
  },
  setBandIds(bandIds) {
    if (import_leaflet11.Util.isArray(bandIds)) {
      this.options.bandIds = bandIds.join(",");
    } else {
      this.options.bandIds = bandIds.toString();
    }
    this._update();
    return this;
  },
  getBandIds() {
    return this.options.bandIds;
  },
  setNoData(noData, noDataInterpretation) {
    if (import_leaflet11.Util.isArray(noData)) {
      this.options.noData = noData.join(",");
    } else {
      this.options.noData = noData.toString();
    }
    if (noDataInterpretation) {
      this.options.noDataInterpretation = noDataInterpretation;
    }
    this._update();
    return this;
  },
  getNoData() {
    return this.options.noData;
  },
  getNoDataInterpretation() {
    return this.options.noDataInterpretation;
  },
  setRenderingRule(renderingRule) {
    this.options.renderingRule = renderingRule;
    this._update();
  },
  getRenderingRule() {
    return this.options.renderingRule;
  },
  setMosaicRule(mosaicRule) {
    this.options.mosaicRule = mosaicRule;
    this._update();
  },
  getMosaicRule() {
    return this.options.mosaicRule;
  },
  _getPopupData(e) {
    const callback = import_leaflet11.Util.bind(function(error, results, response) {
      if (error) {
        return;
      }
      setTimeout(
        import_leaflet11.Util.bind(function() {
          this._renderPopup(e.latlng, error, results, response);
        }, this),
        300
      );
    }, this);
    const identifyRequest = this.identify().at(e.latlng);
    if (this.options.mosaicRule) {
      identifyRequest.setMosaicRule(this.options.mosaicRule);
    }
    identifyRequest.run(callback);
    this._shouldRenderPopup = true;
    this._lastClick = e.latlng;
  },
  _buildExportParams() {
    const sr = parseInt(this._map.options.crs.code.split(":")[1], 10);
    const params = {
      bbox: this._calculateBbox(),
      size: this._calculateImageSize(),
      format: this.options.format,
      transparent: this.options.transparent,
      bboxSR: sr,
      imageSR: sr
    };
    if (this.options.from && this.options.to) {
      params.time = `${this.options.from.valueOf()},${this.options.to.valueOf()}`;
    }
    if (this.options.pixelType) {
      params.pixelType = this.options.pixelType;
    }
    if (this.options.interpolation) {
      params.interpolation = this.options.interpolation;
    }
    if (this.options.compressionQuality) {
      params.compressionQuality = this.options.compressionQuality;
    }
    if (this.options.bandIds) {
      params.bandIds = this.options.bandIds;
    }
    if (this.options.noData === 0 || this.options.noData) {
      params.noData = this.options.noData;
    }
    if (this.options.noDataInterpretation) {
      params.noDataInterpretation = this.options.noDataInterpretation;
    }
    if (this.service.options.token) {
      params.token = this.service.options.token;
    }
    if (this.options.renderingRule) {
      params.renderingRule = JSON.stringify(this.options.renderingRule);
    }
    if (this.options.mosaicRule) {
      params.mosaicRule = JSON.stringify(this.options.mosaicRule);
    }
    return params;
  },
  _requestExport(params, bounds2) {
    if (this.options.f === "json") {
      this.service.request(
        "exportImage",
        params,
        function(error, response) {
          if (error) {
            return;
          }
          if (this.options.token) {
            response.href += `?token=${this.options.token}`;
          }
          if (this.options.proxy) {
            response.href = `${this.options.proxy}?${response.href}`;
          }
          this._renderImage(response.href, bounds2);
        },
        this
      );
    } else {
      params.f = "image";
      let fullUrl = `${this.options.url}exportImage${import_leaflet11.Util.getParamString(params)}`;
      if (this.options.proxy) {
        fullUrl = `${this.options.proxy}?${fullUrl}`;
      }
      this._renderImage(fullUrl, bounds2);
    }
  }
});
function imageMapLayer(url, options2) {
  return new ImageMapLayer(url, options2);
}

// node_modules/esri-leaflet/src/Layers/DynamicMapLayer.js
var import_leaflet12 = __toESM(require_leaflet_src());
var DynamicMapLayer = RasterLayer.extend({
  options: {
    updateInterval: 150,
    layers: false,
    layerDefs: false,
    timeOptions: false,
    format: "png32",
    transparent: true,
    f: "json"
  },
  initialize(options2) {
    options2 = getUrlParams(options2);
    this.service = MapService_default(options2);
    this.service.addEventParent(this);
    import_leaflet12.Util.setOptions(this, options2);
  },
  getDynamicLayers() {
    return this.options.dynamicLayers;
  },
  setDynamicLayers(dynamicLayers) {
    this.options.dynamicLayers = dynamicLayers;
    this._update();
    return this;
  },
  getLayers() {
    return this.options.layers;
  },
  setLayers(layers) {
    this.options.layers = layers;
    this._update();
    return this;
  },
  getLayerDefs() {
    return this.options.layerDefs;
  },
  setLayerDefs(layerDefs) {
    this.options.layerDefs = layerDefs;
    this._update();
    return this;
  },
  getTimeOptions() {
    return this.options.timeOptions;
  },
  setTimeOptions(timeOptions) {
    this.options.timeOptions = timeOptions;
    this._update();
    return this;
  },
  query() {
    return this.service.query();
  },
  identify() {
    return this.service.identify();
  },
  find() {
    return this.service.find();
  },
  _getPopupData(e) {
    const callback = import_leaflet12.Util.bind(function(error, featureCollection, response) {
      if (error) {
        return;
      }
      setTimeout(
        import_leaflet12.Util.bind(function() {
          this._renderPopup(e.latlng, error, featureCollection, response);
        }, this),
        300
      );
    }, this);
    let identifyRequest;
    if (this.options.popup) {
      identifyRequest = this.options.popup.on(this._map).at(e.latlng);
    } else {
      identifyRequest = this.identify().on(this._map).at(e.latlng);
    }
    if (!identifyRequest.params.maxAllowableOffset) {
      identifyRequest.simplify(this._map, 0.5);
    }
    if (!(this.options.popup && this.options.popup.params && this.options.popup.params.layers)) {
      if (this.options.layers) {
        identifyRequest.layers(`visible:${this.options.layers.join(",")}`);
      } else {
        identifyRequest.layers("visible");
      }
    }
    if (this.options.layerDefs && typeof this.options.layerDefs !== "string" && !identifyRequest.params.layerDefs) {
      for (const id in this.options.layerDefs) {
        if (Object.hasOwn(this.options.layerDefs, id)) {
          identifyRequest.layerDef(id, this.options.layerDefs[id]);
        }
      }
    }
    identifyRequest.run(callback);
    this._shouldRenderPopup = true;
    this._lastClick = e.latlng;
  },
  _buildExportParams() {
    const sr = parseInt(this._map.options.crs.code.split(":")[1], 10);
    const params = {
      bbox: this._calculateBbox(),
      size: this._calculateImageSize(),
      dpi: 96,
      format: this.options.format,
      transparent: this.options.transparent,
      bboxSR: sr,
      imageSR: sr
    };
    if (this.options.dynamicLayers) {
      params.dynamicLayers = this.options.dynamicLayers;
    }
    if (this.options.layers) {
      if (this.options.layers.length === 0) {
        return;
      }
      params.layers = `show:${this.options.layers.join(",")}`;
    }
    if (this.options.layerDefs) {
      params.layerDefs = typeof this.options.layerDefs === "string" ? this.options.layerDefs : JSON.stringify(this.options.layerDefs);
    }
    if (this.options.timeOptions) {
      params.timeOptions = JSON.stringify(this.options.timeOptions);
    }
    if (this.options.from && this.options.to) {
      params.time = `${this.options.from.valueOf()},${this.options.to.valueOf()}`;
    }
    if (this.service.options.token) {
      params.token = this.service.options.token;
    }
    if (this.options.proxy) {
      params.proxy = this.options.proxy;
    }
    if (this.options.disableCache) {
      params._ts = Date.now();
    }
    return params;
  },
  _requestExport(params, bounds2) {
    if (this.options.f === "json") {
      this.service.request(
        "export",
        params,
        function(error, response) {
          if (error) {
            return;
          }
          if (this.options.token && response.href) {
            response.href += `?token=${this.options.token}`;
          }
          if (this.options.proxy && response.href) {
            response.href = `${this.options.proxy}?${response.href}`;
          }
          if (response.href) {
            this._renderImage(response.href, bounds2);
          } else {
            this._renderImage(response.imageData, bounds2, response.contentType);
          }
        },
        this
      );
    } else {
      params.f = "image";
      let fullUrl = `${this.options.url}export${import_leaflet12.Util.getParamString(params)}`;
      if (this.options.proxy) {
        fullUrl = `${this.options.proxy}?${fullUrl}`;
      }
      this._renderImage(fullUrl, bounds2);
    }
  }
});
function dynamicMapLayer(url, options2) {
  return new DynamicMapLayer(url, options2);
}

// node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureManager.js
var import_leaflet14 = __toESM(require_leaflet_src());

// node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureGrid.js
var import_leaflet13 = __toESM(require_leaflet_src());
var FeatureGrid = import_leaflet13.Layer.extend({
  // @section
  // @aka GridLayer options
  options: {
    // @option cellSize: Number|Point = 256
    // Width and height of cells in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
    cellSize: 512,
    // @option updateWhenIdle: Boolean = (depends)
    // Load new cells only when panning ends.
    // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
    // `false` otherwise in order to display new cells _during_ panning, since it is easy to pan outside the
    // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
    updateWhenIdle: import_leaflet13.Browser.mobile,
    // @option updateInterval: Number = 150
    // Cells will not update more than once every `updateInterval` milliseconds when panning.
    updateInterval: 150,
    // @option noWrap: Boolean = false
    // Whether the layer is wrapped around the antimeridian. If `true`, the
    // GridLayer will only be displayed once at low zoom levels. Has no
    // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
    // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
    // cells outside the CRS limits.
    noWrap: false,
    // @option keepBuffer: Number = 1.5
    // When panning the map, keep this many rows and columns of cells before unloading them.
    keepBuffer: 1.5
  },
  initialize(options2) {
    import_leaflet13.Util.setOptions(this, options2);
  },
  onAdd() {
    this._cells = {};
    this._activeCells = {};
    this._resetView();
    this._update();
  },
  onRemove() {
    this._removeAllCells();
    this._cellZoom = void 0;
  },
  // @method isLoading: Boolean
  // Returns `true` if any cell in the grid layer has not finished loading.
  isLoading() {
    return this._loading;
  },
  // @method redraw: this
  // Causes the layer to clear all the cells and request them again.
  redraw() {
    if (this._map) {
      this._removeAllCells();
      this._update();
    }
    return this;
  },
  getEvents() {
    const events = {
      viewprereset: this._invalidateAll,
      viewreset: this._resetView,
      zoom: this._resetView,
      moveend: this._onMoveEnd
    };
    if (!this.options.updateWhenIdle) {
      if (!this._onMove) {
        this._onMove = import_leaflet13.Util.throttle(
          this._onMoveEnd,
          this.options.updateInterval,
          this
        );
      }
      events.move = this._onMove;
    }
    return events;
  },
  // @section Extension methods
  // Layers extending `GridLayer` shall reimplement the following method.
  // @method createCell(coords: Object, done?: Function): HTMLElement
  // Called only internally, must be overridden by classes extending `GridLayer`.
  // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
  // is specified, it must be called when the cell has finished loading and drawing.
  createCell() {
    return document.createElement("div");
  },
  removeCell() {
  },
  reuseCell() {
  },
  cellLeave() {
  },
  cellEnter() {
  },
  // @section
  // @method getCellSize: Point
  // Normalizes the [cellSize option](#gridlayer-cellsize) into a point. Used by the `createCell()` method.
  getCellSize() {
    const s = this.options.cellSize;
    return s instanceof import_leaflet13.Point ? s : new import_leaflet13.Point(s, s);
  },
  _pruneCells() {
    if (!this._map) {
      return;
    }
    let key, cell;
    for (key in this._cells) {
      cell = this._cells[key];
      cell.retain = cell.current;
    }
    for (key in this._cells) {
      cell = this._cells[key];
      if (cell.current && !cell.active) {
        const coords = cell.coords;
        if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
          this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
        }
      }
    }
    for (key in this._cells) {
      if (!this._cells[key].retain) {
        this._removeCell(key);
      }
    }
  },
  _removeAllCells() {
    for (const key in this._cells) {
      this._removeCell(key);
    }
  },
  _invalidateAll() {
    this._removeAllCells();
    this._cellZoom = void 0;
  },
  _retainParent(x, y, z, minZoom) {
    const x2 = Math.floor(x / 2);
    const y2 = Math.floor(y / 2);
    const z2 = z - 1;
    const coords2 = new import_leaflet13.Point(+x2, +y2);
    coords2.z = +z2;
    const key = this._cellCoordsToKey(coords2);
    const cell = this._cells[key];
    if (cell && cell.active) {
      cell.retain = true;
      return true;
    } else if (cell && cell.loaded) {
      cell.retain = true;
    }
    if (z2 > minZoom) {
      return this._retainParent(x2, y2, z2, minZoom);
    }
    return false;
  },
  _retainChildren(x, y, z, maxZoom) {
    for (let i = 2 * x; i < 2 * x + 2; i++) {
      for (let j = 2 * y; j < 2 * y + 2; j++) {
        const coords = new import_leaflet13.Point(i, j);
        coords.z = z + 1;
        const key = this._cellCoordsToKey(coords);
        const cell = this._cells[key];
        if (cell && cell.active) {
          cell.retain = true;
          continue;
        } else if (cell && cell.loaded) {
          cell.retain = true;
        }
        if (z + 1 < maxZoom) {
          this._retainChildren(i, j, z + 1, maxZoom);
        }
      }
    }
  },
  _resetView(e) {
    const animating = e && (e.pinch || e.flyTo);
    if (animating) {
      return;
    }
    this._setView(
      this._map.getCenter(),
      this._map.getZoom(),
      animating,
      animating
    );
  },
  _setView(center, zoom, noPrune, noUpdate) {
    const cellZoom = Math.round(zoom);
    if (!noUpdate) {
      this._cellZoom = cellZoom;
      if (this._abortLoading) {
        this._abortLoading();
      }
      this._resetGrid();
      if (cellZoom !== void 0) {
        this._update(center);
      }
      if (!noPrune) {
        this._pruneCells();
      }
      this._noPrune = !!noPrune;
    }
  },
  _resetGrid() {
    const map = this._map;
    const crs = map.options.crs;
    const cellSize = this._cellSize = this.getCellSize();
    const cellZoom = this._cellZoom;
    const bounds2 = this._map.getPixelWorldBounds(this._cellZoom);
    if (bounds2) {
      this._globalCellRange = this._pxBoundsToCellRange(bounds2);
    }
    this._wrapX = crs.wrapLng && !this.options.noWrap && [
      Math.floor(map.project([0, crs.wrapLng[0]], cellZoom).x / cellSize.x),
      Math.ceil(map.project([0, crs.wrapLng[1]], cellZoom).x / cellSize.y)
    ];
    this._wrapY = crs.wrapLat && !this.options.noWrap && [
      Math.floor(map.project([crs.wrapLat[0], 0], cellZoom).y / cellSize.x),
      Math.ceil(map.project([crs.wrapLat[1], 0], cellZoom).y / cellSize.y)
    ];
  },
  _onMoveEnd(e) {
    const animating = e && (e.pinch || e.flyTo);
    if (animating || !this._map || this._map._animatingZoom) {
      return;
    }
    this._update();
  },
  _getCelldPixelBounds(center) {
    const map = this._map;
    const mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom();
    const scale = map.getZoomScale(mapZoom, this._cellZoom);
    const pixelCenter = map.project(center, this._cellZoom).floor();
    const halfSize = map.getSize().divideBy(scale * 2);
    return new import_leaflet13.Bounds(
      pixelCenter.subtract(halfSize),
      pixelCenter.add(halfSize)
    );
  },
  // Private method to load cells in the grid's active zoom level according to map bounds
  _update(center) {
    const map = this._map;
    if (!map) {
      return;
    }
    const zoom = Math.round(map.getZoom());
    if (center === void 0) {
      center = map.getCenter();
    }
    const pixelBounds = this._getCelldPixelBounds(center);
    const cellRange = this._pxBoundsToCellRange(pixelBounds);
    const cellCenter = cellRange.getCenter();
    const queue = [];
    const margin = this.options.keepBuffer;
    const noPruneRange = new import_leaflet13.Bounds(
      cellRange.getBottomLeft().subtract([margin, -margin]),
      cellRange.getTopRight().add([margin, -margin])
    );
    if (!(isFinite(cellRange.min.x) && isFinite(cellRange.min.y) && isFinite(cellRange.max.x) && isFinite(cellRange.max.y))) {
      throw new Error("Attempted to load an infinite number of cells");
    }
    for (const key in this._cells) {
      const c = this._cells[key].coords;
      if (c.z !== this._cellZoom || !noPruneRange.contains(new import_leaflet13.Point(c.x, c.y))) {
        this._cells[key].current = false;
      }
    }
    if (Math.abs(zoom - this._cellZoom) > 1) {
      this._setView(center, zoom);
      return;
    }
    for (let j = cellRange.min.y; j <= cellRange.max.y; j++) {
      for (let i = cellRange.min.x; i <= cellRange.max.x; i++) {
        const coords = new import_leaflet13.Point(i, j);
        coords.z = this._cellZoom;
        if (!this._isValidCell(coords)) {
          continue;
        }
        const cell = this._cells[this._cellCoordsToKey(coords)];
        if (cell) {
          cell.current = true;
        } else {
          queue.push(coords);
        }
      }
    }
    queue.sort((a, b) => a.distanceTo(cellCenter) - b.distanceTo(cellCenter));
    if (queue.length !== 0) {
      if (!this._loading) {
        this._loading = true;
      }
      for (let i = 0; i < queue.length; i++) {
        const _key = this._cellCoordsToKey(queue[i]);
        const _coords = this._keyToCellCoords(_key);
        if (this._activeCells[_coords]) {
          this._reuseCell(queue[i]);
        } else {
          this._createCell(queue[i]);
        }
      }
    }
  },
  _isValidCell(coords) {
    const crs = this._map.options.crs;
    if (!crs.infinite) {
      const bounds2 = this._globalCellRange;
      if (!crs.wrapLng && (coords.x < bounds2.min.x || coords.x > bounds2.max.x) || !crs.wrapLat && (coords.y < bounds2.min.y || coords.y > bounds2.max.y)) {
        return false;
      }
    }
    if (!this.options.bounds) {
      return true;
    }
    const cellBounds = this._cellCoordsToBounds(coords);
    return (0, import_leaflet13.latLngBounds)(this.options.bounds).overlaps(cellBounds);
  },
  _keyToBounds(key) {
    return this._cellCoordsToBounds(this._keyToCellCoords(key));
  },
  _cellCoordsToNwSe(coords) {
    const map = this._map;
    const cellSize = this.getCellSize();
    const nwPoint = coords.scaleBy(cellSize);
    const sePoint = nwPoint.add(cellSize);
    const nw = map.unproject(nwPoint, coords.z);
    const se = map.unproject(sePoint, coords.z);
    return [nw, se];
  },
  // converts cell coordinates to its geographical bounds
  _cellCoordsToBounds(coords) {
    const bp = this._cellCoordsToNwSe(coords);
    let bounds2 = new import_leaflet13.LatLngBounds(bp[0], bp[1]);
    if (!this.options.noWrap) {
      bounds2 = this._map.wrapLatLngBounds(bounds2);
    }
    return bounds2;
  },
  // converts cell coordinates to key for the cell cache
  _cellCoordsToKey(coords) {
    return `${coords.x}:${coords.y}:${coords.z}`;
  },
  // converts cell cache key to coordinates
  _keyToCellCoords(key) {
    const k = key.split(":");
    const coords = new import_leaflet13.Point(+k[0], +k[1]);
    coords.z = +k[2];
    return coords;
  },
  _removeCell(key) {
    const cell = this._cells[key];
    if (!cell) {
      return;
    }
    const coords = this._keyToCellCoords(key);
    const wrappedCoords = this._wrapCoords(coords);
    const cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));
    cell.current = false;
    delete this._cells[key];
    this._activeCells[key] = cell;
    this.cellLeave(cellBounds, wrappedCoords, key);
    this.fire("cellleave", {
      key,
      coords: wrappedCoords,
      bounds: cellBounds
    });
  },
  _reuseCell(coords) {
    const key = this._cellCoordsToKey(coords);
    this._cells[key] = this._activeCells[key];
    this._cells[key].current = true;
    const wrappedCoords = this._wrapCoords(coords);
    const cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));
    this.cellEnter(cellBounds, wrappedCoords, key);
    this.fire("cellenter", {
      key,
      coords: wrappedCoords,
      bounds: cellBounds
    });
  },
  _createCell(coords) {
    const key = this._cellCoordsToKey(coords);
    const wrappedCoords = this._wrapCoords(coords);
    const cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));
    this.createCell(cellBounds, wrappedCoords, key);
    this.fire("cellcreate", {
      key,
      coords: wrappedCoords,
      bounds: cellBounds
    });
    this._cells[key] = {
      coords,
      current: true
    };
    import_leaflet13.Util.requestAnimFrame(this._pruneCells, this);
  },
  _cellReady(coords, err, cell) {
    const key = this._cellCoordsToKey(coords);
    cell = this._cells[key];
    if (!cell) {
      return;
    }
    cell.loaded = +/* @__PURE__ */ new Date();
    cell.active = true;
  },
  _getCellPos(coords) {
    return coords.scaleBy(this.getCellSize());
  },
  _wrapCoords(coords) {
    const newCoords = new import_leaflet13.Point(
      this._wrapX ? import_leaflet13.Util.wrapNum(coords.x, this._wrapX) : coords.x,
      this._wrapY ? import_leaflet13.Util.wrapNum(coords.y, this._wrapY) : coords.y
    );
    newCoords.z = coords.z;
    return newCoords;
  },
  _pxBoundsToCellRange(bounds2) {
    const cellSize = this.getCellSize();
    return new import_leaflet13.Bounds(
      bounds2.min.unscaleBy(cellSize).floor(),
      bounds2.max.unscaleBy(cellSize).ceil().subtract([1, 1])
    );
  }
});

// node_modules/tiny-binary-search/index.js
function BinarySearchIndex(values) {
  this.values = [].concat(values || []);
}
BinarySearchIndex.prototype.query = function(value) {
  var index = this.getIndex(value);
  return this.values[index];
};
BinarySearchIndex.prototype.getIndex = function getIndex(value) {
  if (this.dirty) {
    this.sort();
  }
  var minIndex = 0;
  var maxIndex = this.values.length - 1;
  var currentIndex;
  var currentElement;
  while (minIndex <= maxIndex) {
    currentIndex = (minIndex + maxIndex) / 2 | 0;
    currentElement = this.values[Math.round(currentIndex)];
    if (+currentElement.value < +value) {
      minIndex = currentIndex + 1;
    } else if (+currentElement.value > +value) {
      maxIndex = currentIndex - 1;
    } else {
      return currentIndex;
    }
  }
  return Math.abs(~maxIndex);
};
BinarySearchIndex.prototype.between = function between(start, end) {
  var startIndex = this.getIndex(start);
  var endIndex = this.getIndex(end);
  if (startIndex === 0 && endIndex === 0) {
    return [];
  }
  while (this.values[startIndex - 1] && this.values[startIndex - 1].value === start) {
    startIndex--;
  }
  while (this.values[endIndex + 1] && this.values[endIndex + 1].value === end) {
    endIndex++;
  }
  if (this.values[endIndex] && this.values[endIndex].value === end && this.values[endIndex + 1]) {
    endIndex++;
  }
  return this.values.slice(startIndex, endIndex);
};
BinarySearchIndex.prototype.insert = function insert(item) {
  this.values.splice(this.getIndex(item.value), 0, item);
  return this;
};
BinarySearchIndex.prototype.bulkAdd = function bulkAdd(items, sort2) {
  this.values = this.values.concat([].concat(items || []));
  if (sort2) {
    this.sort();
  } else {
    this.dirty = true;
  }
  return this;
};
BinarySearchIndex.prototype.sort = function sort() {
  this.values.sort(function(a, b) {
    return +b.value - +a.value;
  }).reverse();
  this.dirty = false;
  return this;
};
var tiny_binary_search_default = BinarySearchIndex;

// node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureManager.js
var FeatureManager = FeatureGrid.extend({
  /**
   * Options
   */
  options: {
    attribution: null,
    where: "1=1",
    fields: ["*"],
    from: false,
    to: false,
    timeField: false,
    timeFilterMode: "server",
    simplifyFactor: 0,
    precision: 6,
    fetchAllFeatures: false
  },
  /**
   * Constructor
   */
  initialize(options2) {
    FeatureGrid.prototype.initialize.call(this, options2);
    options2 = getUrlParams(options2);
    options2 = import_leaflet14.Util.setOptions(this, options2);
    this.service = FeatureLayerService_default(options2);
    this.service.addEventParent(this);
    if (this.options.fields[0] !== "*") {
      let oidCheck = false;
      for (let i = 0; i < this.options.fields.length; i++) {
        if (this.options.fields[i].match(/^(OBJECTID|FID|OID|ID)$/i)) {
          oidCheck = true;
        }
      }
      if (oidCheck === false) {
        warn(
          "no known esriFieldTypeOID field detected in fields Array.  Please add an attribute field containing unique IDs to ensure the layer can be drawn correctly."
        );
      }
    }
    if (this.options.timeField.start && this.options.timeField.end) {
      this._startTimeIndex = new tiny_binary_search_default();
      this._endTimeIndex = new tiny_binary_search_default();
    } else if (this.options.timeField) {
      this._timeIndex = new tiny_binary_search_default();
    }
    this._cache = {};
    this._currentSnapshot = [];
    this._activeRequests = 0;
  },
  /**
   * Layer Interface
   */
  onAdd(map) {
    setEsriAttribution(map);
    this.service.metadata(function(err, metadata) {
      if (!err) {
        const supportedFormats = metadata.supportedQueryFormats;
        let forceJsonFormat = false;
        if (this.service.options.isModern === false || this.options.fetchAllFeatures) {
          forceJsonFormat = true;
        }
        if (!forceJsonFormat && supportedFormats && supportedFormats.indexOf("geoJSON") !== -1) {
          this.service.options.isModern = true;
        }
        if (metadata.objectIdField) {
          this.service.options.idAttribute = metadata.objectIdField;
        }
        if (!this.options.attribution && map.attributionControl && metadata.copyrightText) {
          this.options.attribution = metadata.copyrightText;
          map.attributionControl.addAttribution(this.getAttribution());
        }
      }
    }, this);
    map.on("zoomend", this._handleZoomChange, this);
    return FeatureGrid.prototype.onAdd.call(this, map);
  },
  onRemove(map) {
    removeEsriAttribution(map);
    map.off("zoomend", this._handleZoomChange, this);
    return FeatureGrid.prototype.onRemove.call(this, map);
  },
  getAttribution() {
    return this.options.attribution;
  },
  /**
   * Feature Management
   */
  createCell(bounds2, coords) {
    if (this._visibleZoom()) {
      this._requestFeatures(bounds2, coords);
    }
  },
  _requestFeatures(bounds2, coords, callback, offset) {
    this._activeRequests++;
    offset = offset || 0;
    const originalWhere = this.options.where;
    if (this._activeRequests === 1) {
      this.fire(
        "loading",
        {
          bounds: bounds2
        },
        true
      );
    }
    return this._buildQuery(bounds2, offset).run(function(error, featureCollection, response) {
      if (response && response.exceededTransferLimit) {
        this.fire("drawlimitexceeded");
      }
      if (this.options.where !== originalWhere) {
        return;
      }
      if (!error && featureCollection && featureCollection.features.length) {
        import_leaflet14.Util.requestAnimFrame(
          import_leaflet14.Util.bind(function() {
            this._addFeatures(featureCollection.features, coords);
            this._postProcessFeatures(bounds2);
          }, this)
        );
      }
      if (!error && featureCollection && !featureCollection.features.length) {
        this._postProcessFeatures(bounds2);
      }
      if (error) {
        this._postProcessFeatures(bounds2);
      }
      if (callback) {
        callback.call(this, error, featureCollection);
      }
      if (response && (response.exceededTransferLimit || response.properties && response.properties.exceededTransferLimit) && this.options.fetchAllFeatures) {
        this._requestFeatures(
          bounds2,
          coords,
          callback,
          offset + featureCollection.features.length
        );
      }
    }, this);
  },
  _postProcessFeatures(bounds2) {
    this._activeRequests--;
    if (this._activeRequests <= 0) {
      this.fire("load", {
        bounds: bounds2
      });
    }
  },
  _cacheKey(coords) {
    return `${coords.z}:${coords.x}:${coords.y}`;
  },
  _addFeatures(features, coords) {
    let key;
    if (coords) {
      key = this._cacheKey(coords);
      this._cache[key] = this._cache[key] || [];
    }
    for (let i = features.length - 1; i >= 0; i--) {
      const id = features[i].id;
      if (this._currentSnapshot.indexOf(id) === -1) {
        this._currentSnapshot.push(id);
      }
      if (typeof key !== "undefined" && this._cache[key].indexOf(id) === -1) {
        this._cache[key].push(id);
      }
    }
    if (this.options.timeField) {
      this._buildTimeIndexes(features);
    }
    this.createLayers(features);
  },
  _buildQuery(bounds2, offset) {
    let query2 = this.service.query().intersects(bounds2).where(this.options.where).fields(this.options.fields).precision(this.options.precision);
    if (this.options.fetchAllFeatures && !isNaN(parseInt(offset))) {
      query2 = query2.offset(offset);
    }
    query2.params["resultType"] = "tile";
    if (this.options.requestParams) {
      import_leaflet14.Util.extend(query2.params, this.options.requestParams);
    }
    if (this.options.simplifyFactor) {
      query2.simplify(this._map, this.options.simplifyFactor);
    }
    if (this.options.timeFilterMode === "server" && this.options.from && this.options.to) {
      query2.between(this.options.from, this.options.to);
    }
    return query2;
  },
  /**
   * Where Methods
   */
  setWhere(where, callback, context) {
    this.options.where = where && where.length ? where : "1=1";
    const oldSnapshot = [];
    const newSnapshot = [];
    let pendingRequests = 0;
    let requestError = null;
    const requestCallback = import_leaflet14.Util.bind(function(error, featureCollection) {
      if (error) {
        requestError = error;
      }
      if (featureCollection) {
        for (let i = featureCollection.features.length - 1; i >= 0; i--) {
          newSnapshot.push(featureCollection.features[i].id);
        }
      }
      pendingRequests--;
      if (pendingRequests <= 0 && this._visibleZoom() && where === this.options.where) {
        this._currentSnapshot = newSnapshot;
        import_leaflet14.Util.requestAnimFrame(
          import_leaflet14.Util.bind(function() {
            this.removeLayers(oldSnapshot);
            this.addLayers(newSnapshot);
            if (callback) {
              callback.call(context, requestError);
            }
          }, this)
        );
      }
    }, this);
    for (let i = this._currentSnapshot.length - 1; i >= 0; i--) {
      oldSnapshot.push(this._currentSnapshot[i]);
    }
    this._cache = {};
    for (const key in this._cells) {
      pendingRequests++;
      const coords = this._keyToCellCoords(key);
      const bounds2 = this._cellCoordsToBounds(coords);
      this._requestFeatures(bounds2, coords, requestCallback);
    }
    return this;
  },
  getWhere() {
    return this.options.where;
  },
  /**
   * Time Range Methods
   */
  getTimeRange() {
    return [this.options.from, this.options.to];
  },
  setTimeRange(from, to, callback, context) {
    const oldFrom = this.options.from;
    const oldTo = this.options.to;
    let pendingRequests = 0;
    let requestError = null;
    const requestCallback = import_leaflet14.Util.bind(function(error) {
      if (error) {
        requestError = error;
      }
      this._filterExistingFeatures(oldFrom, oldTo, from, to);
      pendingRequests--;
      if (callback && pendingRequests <= 0) {
        callback.call(context, requestError);
      }
    }, this);
    this.options.from = from;
    this.options.to = to;
    this._filterExistingFeatures(oldFrom, oldTo, from, to);
    if (this.options.timeFilterMode === "server") {
      for (const key in this._cells) {
        pendingRequests++;
        const coords = this._keyToCellCoords(key);
        const bounds2 = this._cellCoordsToBounds(coords);
        this._requestFeatures(bounds2, coords, requestCallback);
      }
    }
    return this;
  },
  refresh() {
    this.setWhere(this.options.where);
  },
  _filterExistingFeatures(oldFrom, oldTo, newFrom, newTo) {
    const layersToRemove = oldFrom && oldTo ? this._getFeaturesInTimeRange(oldFrom, oldTo) : this._currentSnapshot;
    const layersToAdd = this._getFeaturesInTimeRange(newFrom, newTo);
    if (layersToAdd.indexOf) {
      for (let i = 0; i < layersToAdd.length; i++) {
        const shouldRemoveLayer = layersToRemove.indexOf(layersToAdd[i]);
        if (shouldRemoveLayer >= 0) {
          layersToRemove.splice(shouldRemoveLayer, 1);
        }
      }
    }
    import_leaflet14.Util.requestAnimFrame(
      import_leaflet14.Util.bind(function() {
        this.removeLayers(layersToRemove);
        this.addLayers(layersToAdd);
      }, this)
    );
  },
  _getFeaturesInTimeRange(start, end) {
    const ids = [];
    let search;
    if (this.options.timeField.start && this.options.timeField.end) {
      const startTimes = this._startTimeIndex.between(start, end);
      const endTimes = this._endTimeIndex.between(start, end);
      search = startTimes.concat(endTimes);
    } else if (this._timeIndex) {
      search = this._timeIndex.between(start, end);
    } else {
      warn(
        "You must set timeField in the layer constructor in order to manipulate the start and end time filter."
      );
      return [];
    }
    for (let i = search.length - 1; i >= 0; i--) {
      ids.push(search[i].id);
    }
    return ids;
  },
  _buildTimeIndexes(geojson) {
    let i;
    let feature;
    if (this.options.timeField.start && this.options.timeField.end) {
      const startTimeEntries = [];
      const endTimeEntries = [];
      for (i = geojson.length - 1; i >= 0; i--) {
        feature = geojson[i];
        startTimeEntries.push({
          id: feature.id,
          value: new Date(feature.properties[this.options.timeField.start])
        });
        endTimeEntries.push({
          id: feature.id,
          value: new Date(feature.properties[this.options.timeField.end])
        });
      }
      this._startTimeIndex.bulkAdd(startTimeEntries);
      this._endTimeIndex.bulkAdd(endTimeEntries);
    } else {
      const timeEntries = [];
      for (i = geojson.length - 1; i >= 0; i--) {
        feature = geojson[i];
        timeEntries.push({
          id: feature.id,
          value: new Date(feature.properties[this.options.timeField])
        });
      }
      this._timeIndex.bulkAdd(timeEntries);
    }
  },
  _featureWithinTimeRange(feature) {
    if (!this.options.from || !this.options.to) {
      return true;
    }
    const from = +this.options.from.valueOf();
    const to = +this.options.to.valueOf();
    if (typeof this.options.timeField === "string") {
      const date = +feature.properties[this.options.timeField];
      return date >= from && date <= to;
    }
    if (this.options.timeField.start && this.options.timeField.end) {
      const startDate = +feature.properties[this.options.timeField.start];
      const endDate = +feature.properties[this.options.timeField.end];
      return startDate >= from && startDate <= to || endDate >= from && endDate <= to || startDate <= from && endDate >= to;
    }
  },
  _visibleZoom() {
    if (!this._map) {
      return false;
    }
    const zoom = this._map.getZoom();
    if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
      return false;
    }
    return true;
  },
  _handleZoomChange() {
    if (!this._visibleZoom()) {
      this.removeLayers(this._currentSnapshot);
      this._currentSnapshot = [];
    } else {
      for (const i in this._cells) {
        const coords = this._cells[i].coords;
        const key = this._cacheKey(coords);
        if (this._cache[key]) {
          this.addLayers(this._cache[key]);
        }
      }
    }
  },
  /**
   * Service Methods
   */
  authenticate(token) {
    this.service.authenticate(token);
    return this;
  },
  metadata(callback, context) {
    this.service.metadata(callback, context);
    return this;
  },
  query() {
    return this.service.query();
  },
  _getMetadata(callback) {
    if (this._metadata) {
      let error;
      callback(error, this._metadata);
    } else {
      this.metadata(
        import_leaflet14.Util.bind(function(error, response) {
          this._metadata = response;
          callback(error, this._metadata);
        }, this)
      );
    }
  },
  addFeature(feature, callback, context) {
    this.addFeatures(feature, callback, context);
  },
  addFeatures(features, callback, context) {
    this._getMetadata(
      import_leaflet14.Util.bind(function(error, metadata) {
        if (error) {
          if (callback) {
            callback.call(this, error, null);
          }
          return;
        }
        const featuresArray = features.features ? features.features : [features];
        this.service.addFeatures(
          features,
          import_leaflet14.Util.bind(function(error2, response) {
            if (!error2) {
              for (let i = featuresArray.length - 1; i >= 0; i--) {
                featuresArray[i].properties[metadata.objectIdField] = featuresArray.length > 1 ? response[i].objectId : response.objectId;
                featuresArray[i].id = featuresArray.length > 1 ? response[i].objectId : response.objectId;
              }
              this._addFeatures(featuresArray);
            }
            if (callback) {
              callback.call(context, error2, response);
            }
          }, this)
        );
      }, this)
    );
  },
  updateFeature(feature, callback, context) {
    this.updateFeatures(feature, callback, context);
  },
  updateFeatures(features, callback, context) {
    const featuresArray = features.features ? features.features : [features];
    this.service.updateFeatures(
      features,
      function(error, response) {
        if (!error) {
          for (let i = featuresArray.length - 1; i >= 0; i--) {
            this.removeLayers([featuresArray[i].id], true);
          }
          this._addFeatures(featuresArray);
        }
        if (callback) {
          callback.call(context, error, response);
        }
      },
      this
    );
  },
  deleteFeature(id, callback, context) {
    this.deleteFeatures(id, callback, context);
  },
  deleteFeatures(ids, callback, context) {
    return this.service.deleteFeatures(
      ids,
      function(error, response) {
        const responseArray = response.length ? response : [response];
        if (!error && responseArray.length > 0) {
          for (let i = responseArray.length - 1; i >= 0; i--) {
            this.removeLayers([responseArray[i].objectId], true);
          }
        }
        if (callback) {
          callback.call(context, error, response);
        }
      },
      this
    );
  }
});

// node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureLayer.js
var import_leaflet15 = __toESM(require_leaflet_src());
var FeatureLayer = FeatureManager.extend({
  options: {
    cacheLayers: true
  },
  /**
   * Constructor
   */
  initialize(options2) {
    if (options2.apikey) {
      options2.token = options2.apikey;
    }
    FeatureManager.prototype.initialize.call(this, options2);
    this._originalStyle = this.options.style;
    this._layers = {};
  },
  /**
   * Layer Interface
   */
  onRemove(map) {
    for (const i in this._layers) {
      map.removeLayer(this._layers[i]);
      this.fire(
        "removefeature",
        {
          feature: this._layers[i].feature,
          permanent: false
        },
        true
      );
    }
    return FeatureManager.prototype.onRemove.call(this, map);
  },
  createNewLayer(geojson) {
    const layer = import_leaflet15.GeoJSON.geometryToLayer(geojson, this.options);
    if (layer) {
      layer.defaultOptions = layer.options;
    }
    return layer;
  },
  _updateLayer(layer, geojson) {
    let latlngs = [];
    const coordsToLatLng = this.options.coordsToLatLng || import_leaflet15.GeoJSON.coordsToLatLng;
    if (geojson.properties) {
      layer.feature.properties = geojson.properties;
    }
    switch (geojson.geometry.type) {
      case "Point":
        latlngs = import_leaflet15.GeoJSON.coordsToLatLng(geojson.geometry.coordinates);
        layer.setLatLng(latlngs);
        break;
      case "LineString":
        latlngs = import_leaflet15.GeoJSON.coordsToLatLngs(
          geojson.geometry.coordinates,
          0,
          coordsToLatLng
        );
        layer.setLatLngs(latlngs);
        break;
      case "MultiLineString":
        latlngs = import_leaflet15.GeoJSON.coordsToLatLngs(
          geojson.geometry.coordinates,
          1,
          coordsToLatLng
        );
        layer.setLatLngs(latlngs);
        break;
      case "Polygon":
        latlngs = import_leaflet15.GeoJSON.coordsToLatLngs(
          geojson.geometry.coordinates,
          1,
          coordsToLatLng
        );
        layer.setLatLngs(latlngs);
        break;
      case "MultiPolygon":
        latlngs = import_leaflet15.GeoJSON.coordsToLatLngs(
          geojson.geometry.coordinates,
          2,
          coordsToLatLng
        );
        layer.setLatLngs(latlngs);
        break;
    }
    this.redraw(layer.feature.id);
  },
  /**
   * Feature Management Methods
   */
  createLayers(features) {
    for (let i = features.length - 1; i >= 0; i--) {
      const geojson = features[i];
      const layer = this._layers[geojson.id];
      let newLayer;
      if (this._visibleZoom() && layer && !this._map.hasLayer(layer) && (!this.options.timeField || this._featureWithinTimeRange(geojson))) {
        this._map.addLayer(layer);
        this.fire(
          "addfeature",
          {
            feature: layer.feature
          },
          true
        );
      }
      if (layer && (layer.setLatLngs || layer.setLatLng)) {
        this._updateLayer(layer, geojson);
      }
      if (!layer) {
        newLayer = this.createNewLayer(geojson);
        if (!newLayer) {
          warn("invalid GeoJSON encountered");
        } else {
          newLayer.feature = geojson;
          newLayer.addEventParent(this);
          if (this.options.onEachFeature) {
            this.options.onEachFeature(newLayer.feature, newLayer);
          }
          this._layers[newLayer.feature.id] = newLayer;
          this.setFeatureStyle(newLayer.feature.id, this.options.style);
          this.fire(
            "createfeature",
            {
              feature: newLayer.feature
            },
            true
          );
          if (this._visibleZoom() && (!this.options.timeField || this.options.timeField && this._featureWithinTimeRange(geojson))) {
            this._map.addLayer(newLayer);
          }
        }
      }
    }
  },
  addLayers(ids) {
    for (let i = ids.length - 1; i >= 0; i--) {
      const layer = this._layers[ids[i]];
      if (layer && (!this.options.timeField || this._featureWithinTimeRange(layer.feature))) {
        this._map.addLayer(layer);
        this.fire(
          "addfeature",
          {
            feature: layer.feature
          },
          true
        );
      }
    }
  },
  removeLayers(ids, permanent) {
    for (let i = ids.length - 1; i >= 0; i--) {
      const id = ids[i];
      const layer = this._layers[id];
      if (layer) {
        this.fire(
          "removefeature",
          {
            feature: layer.feature,
            permanent
          },
          true
        );
        this._map.removeLayer(layer);
      }
      if (layer && permanent) {
        delete this._layers[id];
      }
    }
  },
  cellEnter(bounds2, coords) {
    if (this._visibleZoom() && !this._zooming && this._map) {
      import_leaflet15.Util.requestAnimFrame(
        import_leaflet15.Util.bind(function() {
          const cacheKey = this._cacheKey(coords);
          const cellKey = this._cellCoordsToKey(coords);
          const layers = this._cache[cacheKey];
          if (this._activeCells[cellKey] && layers) {
            this.addLayers(layers);
          }
        }, this)
      );
    }
  },
  cellLeave(bounds2, coords) {
    if (!this._zooming) {
      import_leaflet15.Util.requestAnimFrame(
        import_leaflet15.Util.bind(function() {
          if (this._map) {
            const cacheKey = this._cacheKey(coords);
            const cellKey = this._cellCoordsToKey(coords);
            const layers = this._cache[cacheKey];
            const mapBounds = this._map.getBounds();
            if (!this._activeCells[cellKey] && layers) {
              let removable = true;
              for (let i = 0; i < layers.length; i++) {
                const layer = this._layers[layers[i]];
                if (layer && layer.getBounds && mapBounds.intersects(layer.getBounds())) {
                  removable = false;
                }
              }
              if (removable) {
                this.removeLayers(layers, !this.options.cacheLayers);
              }
              if (!this.options.cacheLayers && removable) {
                delete this._cache[cacheKey];
                delete this._cells[cellKey];
                delete this._activeCells[cellKey];
              }
            }
          }
        }, this)
      );
    }
  },
  /**
   * Styling Methods
   */
  resetStyle() {
    this.options.style = this._originalStyle;
    this.eachFeature(function(layer) {
      this.resetFeatureStyle(layer.feature.id);
    }, this);
    return this;
  },
  setStyle(style) {
    this.options.style = style;
    this.eachFeature(function(layer) {
      this.setFeatureStyle(layer.feature.id, style);
    }, this);
    return this;
  },
  resetFeatureStyle(id) {
    const layer = this._layers[id];
    const style = this._originalStyle || import_leaflet15.Path.prototype.options;
    if (layer) {
      import_leaflet15.Util.extend(layer.options, layer.defaultOptions);
      this.setFeatureStyle(id, style);
    }
    return this;
  },
  setFeatureStyle(id, style) {
    const layer = this._layers[id];
    if (typeof style === "function") {
      style = style(layer.feature);
    }
    if (layer.setStyle) {
      layer.setStyle(style);
    }
    return this;
  },
  /**
   * Utility Methods
   */
  eachActiveFeature(fn, context) {
    if (this._map) {
      const activeBounds = this._map.getBounds();
      for (const i in this._layers) {
        if (this._currentSnapshot.indexOf(this._layers[i].feature.id) !== -1) {
          if (typeof this._layers[i].getLatLng === "function" && activeBounds.contains(this._layers[i].getLatLng())) {
            fn.call(context, this._layers[i]);
          } else if (typeof this._layers[i].getBounds === "function" && activeBounds.intersects(this._layers[i].getBounds())) {
            fn.call(context, this._layers[i]);
          }
        }
      }
    }
    return this;
  },
  eachFeature(fn, context) {
    for (const i in this._layers) {
      fn.call(context, this._layers[i]);
    }
    return this;
  },
  getFeature(id) {
    return this._layers[id];
  },
  bringToBack() {
    this.eachFeature((layer) => {
      if (layer.bringToBack) {
        layer.bringToBack();
      }
    });
  },
  bringToFront() {
    this.eachFeature((layer) => {
      if (layer.bringToFront) {
        layer.bringToFront();
      }
    });
  },
  redraw(id) {
    if (id) {
      this._redraw(id);
    }
    return this;
  },
  _redraw(id) {
    const layer = this._layers[id];
    const geojson = layer.feature;
    if (layer && layer.setIcon && this.options.pointToLayer) {
      if (this.options.pointToLayer) {
        const getIcon = this.options.pointToLayer(
          geojson,
          (0, import_leaflet15.latLng)(
            geojson.geometry.coordinates[1],
            geojson.geometry.coordinates[0]
          )
        );
        const updatedIcon = getIcon.options.icon;
        layer.setIcon(updatedIcon);
      }
    }
    if (layer && layer.setStyle && this.options.pointToLayer) {
      const getStyle = this.options.pointToLayer(
        geojson,
        (0, import_leaflet15.latLng)(
          geojson.geometry.coordinates[1],
          geojson.geometry.coordinates[0]
        )
      );
      const updatedStyle = getStyle.options;
      this.setFeatureStyle(geojson.id, updatedStyle);
    }
    if (layer && layer.setStyle && this.options.style) {
      this.resetFeatureStyle(geojson.id);
    }
  },
  // This is the same as the Layer.openPopup method except it excludes the `FeatureGroup`
  // logic to work around https://github.com/Leaflet/Leaflet/issues/8761
  openPopup(latlng) {
    if (this._popup) {
      if (this._popup._prepareOpen(latlng || this._latlng)) {
        this._popup.openOn(this._map);
      }
    }
    return this;
  },
  // This is the same as the `Layer.openTooltip` method except it excludes the `FeatureGroup`
  // logic to work around https://github.com/Leaflet/Leaflet/issues/8761
  openTooltip(latlng) {
    if (this._tooltip) {
      if (this._tooltip._prepareOpen(latlng)) {
        this._tooltip.openOn(this._map);
        if (this.getElement) {
          this._setAriaDescribedByOnLayer(this);
        } else if (this.eachLayer) {
          this.eachLayer(this._setAriaDescribedByOnLayer, this);
        }
      }
    }
    return this;
  }
});
function featureLayer(options2) {
  return new FeatureLayer(options2);
}

// node_modules/esri-leaflet/src/EsriLeaflet.js
var version = package_default.version;
export {
  BasemapLayer,
  DynamicMapLayer,
  FeatureLayer,
  FeatureLayerService,
  FeatureManager,
  Find,
  Identify,
  IdentifyFeatures,
  IdentifyImage,
  ImageMapLayer,
  ImageService,
  MapService,
  Query,
  RasterLayer,
  Service,
  Support,
  Task,
  TiledMapLayer,
  EsriUtil as Util,
  version as VERSION,
  basemapLayer,
  dynamicMapLayer,
  featureLayer,
  featureLayerService,
  find,
  get,
  identify,
  identifyFeatures,
  identifyImage,
  imageMapLayer,
  imageService,
  mapService,
  options,
  xmlHttpPost as post,
  query,
  request,
  service,
  task,
  tiledMapLayer
};
//# sourceMappingURL=esri-leaflet.js.map
