{
  "version": 3,
  "sources": ["../../kdbush/index.js", "../../supercluster/index.js"],
  "sourcesContent": ["\nconst ARRAY_TYPES = [\n    Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,\n    Int32Array, Uint32Array, Float32Array, Float64Array\n];\n\n/** @typedef {Int8ArrayConstructor | Uint8ArrayConstructor | Uint8ClampedArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor} TypedArrayConstructor */\n\nconst VERSION = 1; // serialized format version\nconst HEADER_SIZE = 8;\n\nexport default class KDBush {\n\n    /**\n     * Creates an index from raw `ArrayBuffer` data.\n     * @param {ArrayBuffer} data\n     */\n    static from(data) {\n        if (!(data instanceof ArrayBuffer)) {\n            throw new Error('Data must be an instance of ArrayBuffer.');\n        }\n        const [magic, versionAndType] = new Uint8Array(data, 0, 2);\n        if (magic !== 0xdb) {\n            throw new Error('Data does not appear to be in a KDBush format.');\n        }\n        const version = versionAndType >> 4;\n        if (version !== VERSION) {\n            throw new Error(`Got v${version} data when expected v${VERSION}.`);\n        }\n        const ArrayType = ARRAY_TYPES[versionAndType & 0x0f];\n        if (!ArrayType) {\n            throw new Error('Unrecognized array type.');\n        }\n        const [nodeSize] = new Uint16Array(data, 2, 1);\n        const [numItems] = new Uint32Array(data, 4, 1);\n\n        return new KDBush(numItems, nodeSize, ArrayType, data);\n    }\n\n    /**\n     * Creates an index that will hold a given number of items.\n     * @param {number} numItems\n     * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).\n     * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).\n     * @param {ArrayBuffer} [data] (For internal use only)\n     */\n    constructor(numItems, nodeSize = 64, ArrayType = Float64Array, data) {\n        if (isNaN(numItems) || numItems < 0) throw new Error(`Unpexpected numItems value: ${numItems}.`);\n\n        this.numItems = +numItems;\n        this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);\n        this.ArrayType = ArrayType;\n        this.IndexArrayType = numItems < 65536 ? Uint16Array : Uint32Array;\n\n        const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);\n        const coordsByteSize = numItems * 2 * this.ArrayType.BYTES_PER_ELEMENT;\n        const idsByteSize = numItems * this.IndexArrayType.BYTES_PER_ELEMENT;\n        const padCoords = (8 - idsByteSize % 8) % 8;\n\n        if (arrayTypeIndex < 0) {\n            throw new Error(`Unexpected typed array class: ${ArrayType}.`);\n        }\n\n        if (data && (data instanceof ArrayBuffer)) { // reconstruct an index from a buffer\n            this.data = data;\n            this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);\n            this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);\n            this._pos = numItems * 2;\n            this._finished = true;\n        } else { // initialize a new index\n            this.data = new ArrayBuffer(HEADER_SIZE + coordsByteSize + idsByteSize + padCoords);\n            this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);\n            this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);\n            this._pos = 0;\n            this._finished = false;\n\n            // set header\n            new Uint8Array(this.data, 0, 2).set([0xdb, (VERSION << 4) + arrayTypeIndex]);\n            new Uint16Array(this.data, 2, 1)[0] = nodeSize;\n            new Uint32Array(this.data, 4, 1)[0] = numItems;\n        }\n    }\n\n    /**\n     * Add a point to the index.\n     * @param {number} x\n     * @param {number} y\n     * @returns {number} An incremental index associated with the added item (starting from `0`).\n     */\n    add(x, y) {\n        const index = this._pos >> 1;\n        this.ids[index] = index;\n        this.coords[this._pos++] = x;\n        this.coords[this._pos++] = y;\n        return index;\n    }\n\n    /**\n     * Perform indexing of the added points.\n     */\n    finish() {\n        const numAdded = this._pos >> 1;\n        if (numAdded !== this.numItems) {\n            throw new Error(`Added ${numAdded} items when expected ${this.numItems}.`);\n        }\n        // kd-sort both arrays for efficient search\n        sort(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0);\n\n        this._finished = true;\n        return this;\n    }\n\n    /**\n     * Search the index for items within a given bounding box.\n     * @param {number} minX\n     * @param {number} minY\n     * @param {number} maxX\n     * @param {number} maxY\n     * @returns {number[]} An array of indices correponding to the found items.\n     */\n    range(minX, minY, maxX, maxY) {\n        if (!this._finished) throw new Error('Data not yet indexed - call index.finish().');\n\n        const {ids, coords, nodeSize} = this;\n        const stack = [0, ids.length - 1, 0];\n        const result = [];\n\n        // recursively search for items in range in the kd-sorted arrays\n        while (stack.length) {\n            const axis = stack.pop() || 0;\n            const right = stack.pop() || 0;\n            const left = stack.pop() || 0;\n\n            // if we reached \"tree node\", search linearly\n            if (right - left <= nodeSize) {\n                for (let i = left; i <= right; i++) {\n                    const x = coords[2 * i];\n                    const y = coords[2 * i + 1];\n                    if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n                }\n                continue;\n            }\n\n            // otherwise find the middle index\n            const m = (left + right) >> 1;\n\n            // include the middle item if it's in range\n            const x = coords[2 * m];\n            const y = coords[2 * m + 1];\n            if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n            // queue search in halves that intersect the query\n            if (axis === 0 ? minX <= x : minY <= y) {\n                stack.push(left);\n                stack.push(m - 1);\n                stack.push(1 - axis);\n            }\n            if (axis === 0 ? maxX >= x : maxY >= y) {\n                stack.push(m + 1);\n                stack.push(right);\n                stack.push(1 - axis);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Search the index for items within a given radius.\n     * @param {number} qx\n     * @param {number} qy\n     * @param {number} r Query radius.\n     * @returns {number[]} An array of indices correponding to the found items.\n     */\n    within(qx, qy, r) {\n        if (!this._finished) throw new Error('Data not yet indexed - call index.finish().');\n\n        const {ids, coords, nodeSize} = this;\n        const stack = [0, ids.length - 1, 0];\n        const result = [];\n        const r2 = r * r;\n\n        // recursively search for items within radius in the kd-sorted arrays\n        while (stack.length) {\n            const axis = stack.pop() || 0;\n            const right = stack.pop() || 0;\n            const left = stack.pop() || 0;\n\n            // if we reached \"tree node\", search linearly\n            if (right - left <= nodeSize) {\n                for (let i = left; i <= right; i++) {\n                    if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n                }\n                continue;\n            }\n\n            // otherwise find the middle index\n            const m = (left + right) >> 1;\n\n            // include the middle item if it's in range\n            const x = coords[2 * m];\n            const y = coords[2 * m + 1];\n            if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n            // queue search in halves that intersect the query\n            if (axis === 0 ? qx - r <= x : qy - r <= y) {\n                stack.push(left);\n                stack.push(m - 1);\n                stack.push(1 - axis);\n            }\n            if (axis === 0 ? qx + r >= x : qy + r >= y) {\n                stack.push(m + 1);\n                stack.push(right);\n                stack.push(1 - axis);\n            }\n        }\n\n        return result;\n    }\n}\n\n/**\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} nodeSize\n * @param {number} left\n * @param {number} right\n * @param {number} axis\n */\nfunction sort(ids, coords, nodeSize, left, right, axis) {\n    if (right - left <= nodeSize) return;\n\n    const m = (left + right) >> 1; // middle index\n\n    // sort ids and coords around the middle index so that the halves lie\n    // either left/right or top/bottom correspondingly (taking turns)\n    select(ids, coords, m, left, right, axis);\n\n    // recursively kd-sort first half and second half on the opposite axis\n    sort(ids, coords, nodeSize, left, m - 1, 1 - axis);\n    sort(ids, coords, nodeSize, m + 1, right, 1 - axis);\n}\n\n/**\n * Custom Floyd-Rivest selection algorithm: sort ids and coords so that\n * [left..k-1] items are smaller than k-th item (on either x or y axis)\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} k\n * @param {number} left\n * @param {number} right\n * @param {number} axis\n */\nfunction select(ids, coords, k, left, right, axis) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, axis);\n        }\n\n        const t = coords[2 * k + axis];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + axis] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + axis] < t) i++;\n            while (coords[2 * j + axis] > t) j--;\n        }\n\n        if (coords[2 * left + axis] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\n/**\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} i\n * @param {number} j\n */\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\n/**\n * @param {InstanceType<TypedArrayConstructor>} arr\n * @param {number} i\n * @param {number} j\n */\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\n/**\n * @param {number} ax\n * @param {number} ay\n * @param {number} bx\n * @param {number} by\n */\nfunction sqDist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n", "\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nconst OFFSET_ZOOM = 2;\nconst OFFSET_ID = 3;\nconst OFFSET_PARENT = 4;\nconst OFFSET_NUM = 5;\nconst OFFSET_PROP = 6;\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = Object.assign(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n        this.stride = this.options.reduce ? 7 : 6;\n        this.clusterProps = [];\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        const data = [];\n\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            if (!p.geometry) continue;\n\n            const [lng, lat] = p.geometry.coordinates;\n            const x = fround(lngX(lng));\n            const y = fround(latY(lat));\n            // store internal point/cluster data in flat numeric arrays for performance\n            data.push(\n                x, y, // projected point coordinates\n                Infinity, // the last zoom the point was processed at\n                i, // index of the source feature in the original input array\n                -1, // parent cluster id\n                1 // number of points in a cluster\n            );\n            if (this.options.reduce) data.push(0); // noop\n        }\n        let tree = this.trees[maxZoom + 1] = this._createTree(data);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            tree = this.trees[z] = this._createTree(this._cluster(tree, z));\n\n            if (log) console.log('z%d: %d clusters in %dms', z, tree.numItems, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const data = tree.data;\n        const clusters = [];\n        for (const id of ids) {\n            const k = this.stride * id;\n            clusters.push(data[k + OFFSET_NUM] > 1 ? getClusterJSON(data, k, this.clusterProps) : this.points[data[k + OFFSET_ID]]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const tree = this.trees[originZoom];\n        if (!tree) throw new Error(errorMsg);\n\n        const data = tree.data;\n        if (originId * this.stride >= data.length) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const x = data[originId * this.stride];\n        const y = data[originId * this.stride + 1];\n        const ids = tree.within(x, y, r);\n        const children = [];\n        for (const id of ids) {\n            const k = id * this.stride;\n            if (data[k + OFFSET_PARENT] === clusterId) {\n                children.push(data[k + OFFSET_NUM] > 1 ? getClusterJSON(data, k, this.clusterProps) : this.points[data[k + OFFSET_ID]]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.data, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.data, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.data, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _createTree(data) {\n        const tree = new KDBush(data.length / this.stride | 0, this.options.nodeSize, Float32Array);\n        for (let i = 0; i < data.length; i += this.stride) tree.add(data[i], data[i + 1]);\n        tree.finish();\n        tree.data = data;\n        return tree;\n    }\n\n    _addTileFeatures(ids, data, x, y, z2, tile) {\n        for (const i of ids) {\n            const k = i * this.stride;\n            const isCluster = data[k + OFFSET_NUM] > 1;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(data, k, this.clusterProps);\n                px = data[k];\n                py = data[k + 1];\n            } else {\n                const p = this.points[data[k + OFFSET_ID]];\n                tags = p.properties;\n                const [lng, lat] = p.geometry.coordinates;\n                px = lngX(lng);\n                py = latY(lat);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster || this.options.generateId) {\n                // optionally generate id for points\n                id = data[k + OFFSET_ID];\n            } else {\n                // keep id if already assigned\n                id = this.points[data[k + OFFSET_ID]].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n    }\n\n    _cluster(tree, zoom) {\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n        const data = tree.data;\n        const nextData = [];\n        const stride = this.stride;\n\n        // loop through each point\n        for (let i = 0; i < data.length; i += stride) {\n            // if we've already visited the point at this zoom level, skip it\n            if (data[i + OFFSET_ZOOM] <= zoom) continue;\n            data[i + OFFSET_ZOOM] = zoom;\n\n            // find all nearby points\n            const x = data[i];\n            const y = data[i + 1];\n            const neighborIds = tree.within(data[i], data[i + 1], r);\n\n            const numPointsOrigin = data[i + OFFSET_NUM];\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const k = neighborId * stride;\n                // filter out neighbors that are already processed\n                if (data[k + OFFSET_ZOOM] > zoom) numPoints += data[k + OFFSET_NUM];\n            }\n\n            // if there were neighbors to merge, and there are enough points to form a cluster\n            if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n                let wx = x * numPointsOrigin;\n                let wy = y * numPointsOrigin;\n\n                let clusterProperties;\n                let clusterPropIndex = -1;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = ((i / stride | 0) << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const k = neighborId * stride;\n\n                    if (data[k + OFFSET_ZOOM] <= zoom) continue;\n                    data[k + OFFSET_ZOOM] = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = data[k + OFFSET_NUM];\n                    wx += data[k] * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += data[k + 1] * numPoints2;\n\n                    data[k + OFFSET_PARENT] = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) {\n                            clusterProperties = this._map(data, i, true);\n                            clusterPropIndex = this.clusterProps.length;\n                            this.clusterProps.push(clusterProperties);\n                        }\n                        reduce(clusterProperties, this._map(data, k));\n                    }\n                }\n\n                data[i + OFFSET_PARENT] = id;\n                nextData.push(wx / numPoints, wy / numPoints, Infinity, id, -1, numPoints);\n                if (reduce) nextData.push(clusterPropIndex);\n\n            } else { // left points as unclustered\n                for (let j = 0; j < stride; j++) nextData.push(data[i + j]);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const k = neighborId * stride;\n                        if (data[k + OFFSET_ZOOM] <= zoom) continue;\n                        data[k + OFFSET_ZOOM] = zoom;\n                        for (let j = 0; j < stride; j++) nextData.push(data[k + j]);\n                    }\n                }\n            }\n        }\n\n        return nextData;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(data, i, clone) {\n        if (data[i + OFFSET_NUM] > 1) {\n            const props = this.clusterProps[data[i + OFFSET_PROP]];\n            return clone ? Object.assign({}, props) : props;\n        }\n        const original = this.points[data[i + OFFSET_ID]].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? Object.assign({}, result) : result;\n    }\n}\n\nfunction getClusterJSON(data, i, clusterProps) {\n    return {\n        type: 'Feature',\n        id: data[i + OFFSET_ID],\n        properties: getClusterProperties(data, i, clusterProps),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(data[i]), yLat(data[i + 1])]\n        }\n    };\n}\n\nfunction getClusterProperties(data, i, clusterProps) {\n    const count = data[i + OFFSET_NUM];\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    const propIndex = data[i + OFFSET_PROP];\n    const properties = propIndex === -1 ? {} : Object.assign({}, clusterProps[propIndex]);\n    return Object.assign(properties, {\n        cluster: true,\n        cluster_id: data[i + OFFSET_ID],\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n"],
  "mappings": "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",
  "names": ["x", "y"]
}
